/* tslint:disable */
/* eslint-disable */
/**
 * FlowAccount Open API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface APIResponseOfBoolean
 */
export interface APIResponseOfBoolean {
    /**
     * 
     * @type {boolean}
     * @memberof APIResponseOfBoolean
     */
    'status'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof APIResponseOfBoolean
     */
    'message'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof APIResponseOfBoolean
     */
    'code'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof APIResponseOfBoolean
     */
    'data'?: boolean;
}
/**
 * 
 * @export
 * @interface APIResponseOfISimpleListResultOfIProductResult
 */
export interface APIResponseOfISimpleListResultOfIProductResult {
    /**
     * 
     * @type {boolean}
     * @memberof APIResponseOfISimpleListResultOfIProductResult
     */
    'status'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof APIResponseOfISimpleListResultOfIProductResult
     */
    'message'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof APIResponseOfISimpleListResultOfIProductResult
     */
    'code'?: number;
    /**
     * 
     * @type {ISimpleListResultOfIProductResult}
     * @memberof APIResponseOfISimpleListResultOfIProductResult
     */
    'data'?: ISimpleListResultOfIProductResult | null;
}
/**
 * 0 = Default 1 = DisastersFire 3 = StolenGoods 5 = StockWrittenOff 7 = StockTakingResults 9 = ReturnedStock 11 = DamagedGoods 13 = RawMaterialUsed 15 = FinishedGoodsTransfer 17 = Other
 * @export
 * @enum {string}
 */

export const AdjustInventoryReason = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7,
    NUMBER_9: 9,
    NUMBER_11: 11,
    NUMBER_13: 13,
    NUMBER_15: 15,
    NUMBER_17: 17
} as const;

export type AdjustInventoryReason = typeof AdjustInventoryReason[keyof typeof AdjustInventoryReason];


/**
 * 
 * @export
 * @interface Bank
 */
export interface Bank {
    /**
     * 
     * @type {string}
     * @memberof Bank
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Bank
     */
    'countryCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Bank
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Bank
     */
    'bankCode': string;
    /**
     * 
     * @type {boolean}
     * @memberof Bank
     */
    'isDelete'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Bank
     */
    'orderNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof Bank
     */
    'url'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Bank
     */
    'isCustomBank'?: boolean;
    /**
     * 
     * @type {Array<BankAccount>}
     * @memberof Bank
     */
    'bankAccount'?: Array<BankAccount> | null;
    /**
     * 
     * @type {Array<ReconciledDocument>}
     * @memberof Bank
     */
    'reconciledDocument'?: Array<ReconciledDocument> | null;
}
/**
 * 
 * @export
 * @interface BankAccount
 */
export interface BankAccount {
    /**
     * 
     * @type {number}
     * @memberof BankAccount
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof BankAccount
     */
    'companyId': number;
    /**
     * 
     * @type {string}
     * @memberof BankAccount
     */
    'accountNumber'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BankAccount
     */
    'bankId'?: number;
    /**
     * 
     * @type {string}
     * @memberof BankAccount
     */
    'branch'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankAccount
     */
    'accountName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BankAccount
     */
    'accountType'?: number;
    /**
     * 
     * @type {string}
     * @memberof BankAccount
     */
    'lastReconciledDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankAccount
     */
    'lastOutstandingBalanceDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankAccount
     */
    'lastStatementDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankAccount
     */
    'lastStatementDocumentId'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BankAccount
     */
    'synced'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof BankAccount
     */
    'outstandingBalance'?: number;
    /**
     * 
     * @type {string}
     * @memberof BankAccount
     */
    'createdOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccount
     */
    'modifiedOn'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BankAccount
     */
    'isDefault'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BankAccount
     */
    'isDelete'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof BankAccount
     */
    'lastAvailableBalance'?: number;
    /**
     * 
     * @type {number}
     * @memberof BankAccount
     */
    'lastOutstandingBalance'?: number;
    /**
     * 
     * @type {number}
     * @memberof BankAccount
     */
    'chartOfAccountId'?: number | null;
    /**
     * 
     * @type {ChartOfAccount}
     * @memberof BankAccount
     */
    'chartOfAccount'?: ChartOfAccount | null;
    /**
     * 
     * @type {Bank}
     * @memberof BankAccount
     */
    'bank'?: Bank | null;
    /**
     * 
     * @type {Company}
     * @memberof BankAccount
     */
    'company'?: Company | null;
    /**
     * 
     * @type {BankingChannelsStatus}
     * @memberof BankAccount
     */
    'status'?: BankingChannelsStatus;
    /**
     * 
     * @type {string}
     * @memberof BankAccount
     */
    'bankName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankAccount
     */
    'qrCode'?: string | null;
}
/**
 * 1 = SavingAccount 3 = CurrentAccount 5 = CreditCardAccount 7 = DepositAccount
 * @export
 * @enum {string}
 */

export const BankAccountType = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7
} as const;

export type BankAccountType = typeof BankAccountType[keyof typeof BankAccountType];


/**
 * 1 = Active 3 = InActive
 * @export
 * @enum {string}
 */

export const BankingChannelsStatus = {
    NUMBER_1: 1,
    NUMBER_3: 3
} as const;

export type BankingChannelsStatus = typeof BankingChannelsStatus[keyof typeof BankingChannelsStatus];


/**
 * 
 * @export
 * @interface BatchHistory
 */
export interface BatchHistory {
    /**
     * 
     * @type {Array<BatchImportMetadata>}
     * @memberof BatchHistory
     */
    'metadataList'?: Array<BatchImportMetadata> | null;
}
/**
 * 
 * @export
 * @interface BatchImportMetadata
 */
export interface BatchImportMetadata {
    /**
     * 
     * @type {string}
     * @memberof BatchImportMetadata
     */
    'companyUserGuid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchImportMetadata
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchImportMetadata
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchImportMetadata
     */
    'templateId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchImportMetadata
     */
    'batchId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchImportMetadata
     */
    'filename'?: string | null;
    /**
     * 
     * @type {DocumentTypes}
     * @memberof BatchImportMetadata
     */
    'documentType'?: DocumentTypes;
    /**
     * 
     * @type {BatchImportStatus}
     * @memberof BatchImportMetadata
     */
    'status'?: BatchImportStatus;
    /**
     * 
     * @type {number}
     * @memberof BatchImportMetadata
     */
    'documentCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchImportMetadata
     */
    'successCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchImportMetadata
     */
    'failedCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof BatchImportMetadata
     */
    's3Key'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BatchImportMetadata
     */
    'userId'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchImportMetadata
     */
    'companyId'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof BatchImportMetadata
     */
    'isViewed'?: boolean;
}
/**
 * 
 * @export
 * @interface BatchImportPayload
 */
export interface BatchImportPayload {
    /**
     * 
     * @type {Array<SimpleDocument>}
     * @memberof BatchImportPayload
     */
    'simpleDocuments'?: Array<SimpleDocument> | null;
    /**
     * 
     * @type {string}
     * @memberof BatchImportPayload
     */
    'batchId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchImportPayload
     */
    'fileName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BatchImportPayload
     */
    'batchCount'?: number;
}
/**
 * 
 * @export
 * @interface BatchImportRetry
 */
export interface BatchImportRetry {
    /**
     * 
     * @type {string}
     * @memberof BatchImportRetry
     */
    'batchId'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof BatchImportRetry
     */
    'messageIds'?: Array<string> | null;
}
/**
 * 0 = None 1 = Awaiting 3 = Pending 5 = Failed 6 = HandledDuplicated 7 = Succeed
 * @export
 * @enum {string}
 */

export const BatchImportStatus = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_6: 6,
    NUMBER_7: 7
} as const;

export type BatchImportStatus = typeof BatchImportStatus[keyof typeof BatchImportStatus];


/**
 * 
 * @export
 * @interface BatchMessageStatus
 */
export interface BatchMessageStatus {
    /**
     * 
     * @type {string}
     * @memberof BatchMessageStatus
     */
    'companyUserGuid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchMessageStatus
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchMessageStatus
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchMessageStatus
     */
    'batchId'?: string | null;
    /**
     * 
     * @type {BatchImportStatus}
     * @memberof BatchMessageStatus
     */
    'status'?: BatchImportStatus;
    /**
     * 
     * @type {string}
     * @memberof BatchMessageStatus
     */
    'messageId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchMessageStatus
     */
    'failedReason'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchMessageStatus
     */
    'payload'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BatchMessageStatus
     */
    'retryCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof BatchMessageStatus
     */
    'documentSerial'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BatchMessageStatus
     */
    'sqlId'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchMessageStatus
     */
    'rowIndex'?: number;
}
/**
 * 
 * @export
 * @interface BatchStatus
 */
export interface BatchStatus {
    /**
     * 
     * @type {Array<BatchMessageStatus>}
     * @memberof BatchStatus
     */
    'messages'?: Array<BatchMessageStatus> | null;
    /**
     * 
     * @type {BatchImportMetadata}
     * @memberof BatchStatus
     */
    'metadata'?: BatchImportMetadata | null;
}
/**
 * 
 * @export
 * @interface BatchTaxFiling
 */
export interface BatchTaxFiling {
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'companyId': number;
    /**
     * 
     * @type {BatchTaxFilingStatus}
     * @memberof BatchTaxFiling
     */
    'status'?: BatchTaxFilingStatus;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFiling
     */
    'claimDate': string;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'totalBuyValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'totalBuyVatValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'totalSellValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'totalSellVatValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'broughtForward'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'value'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof BatchTaxFiling
     */
    'isDelete'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'createdBy'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'modifiedBy'?: number;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFiling
     */
    'createdOn': string;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFiling
     */
    'modifiedOn': string;
    /**
     * 
     * @type {Company}
     * @memberof BatchTaxFiling
     */
    'company'?: Company | null;
    /**
     * 
     * @type {User}
     * @memberof BatchTaxFiling
     */
    'createdByUser'?: User | null;
    /**
     * 
     * @type {User}
     * @memberof BatchTaxFiling
     */
    'modifiedByUser'?: User | null;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFiling
     */
    'datePayment'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'charge'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'collected'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'tax'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFiling
     */
    'remarks'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'paymentWithHeld'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'remainingCollected'?: number | null;
    /**
     * 
     * @type {RemainingCollectedType}
     * @memberof BatchTaxFiling
     */
    'remainingCollectedType'?: RemainingCollectedType | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'deductionAmount'?: number | null;
    /**
     * 
     * @type {DeductionType}
     * @memberof BatchTaxFiling
     */
    'paymentDeductionType'?: DeductionType | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'bankAccountId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFiling
     */
    'checkNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFiling
     */
    'checkBankId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFiling
     */
    'transferBankId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFiling
     */
    'bankAccountNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFiling
     */
    'checkDatePaid'?: string | null;
    /**
     * 
     * @type {PaymentMethod}
     * @memberof BatchTaxFiling
     */
    'methodPayment'?: PaymentMethod | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'no'?: number;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFiling
     */
    'pettyCashName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'pettyCashId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'chequeId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'creditCardId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'otherChannelId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFiling
     */
    'documentSerial'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFiling
     */
    'documentId'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BatchTaxFiling
     */
    'approved'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFiling
     */
    'publishedOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFiling
     */
    'documentDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'vatRate'?: number;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFiling
     */
    'dueDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFiling
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFiling
     */
    'internalNotes'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'roundingAdjustment'?: number;
    /**
     * 
     * @type {Gallery}
     * @memberof BatchTaxFiling
     */
    'gallery'?: Gallery | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'galleryId'?: number | null;
    /**
     * 
     * @type {Contact}
     * @memberof BatchTaxFiling
     */
    'contact'?: Contact | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'contactId'?: number;
    /**
     * 
     * @type {Array<IDocumentReference>}
     * @memberof BatchTaxFiling
     */
    'documentReferences'?: Array<IDocumentReference> | null;
    /**
     * 
     * @type {Array<IDocumentReference>}
     * @memberof BatchTaxFiling
     */
    'referencedToMe'?: Array<IDocumentReference> | null;
    /**
     * 
     * @type {Array<IDocumentReference>}
     * @memberof BatchTaxFiling
     */
    'referencedByMe'?: Array<IDocumentReference> | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'statusInt'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof BatchTaxFiling
     */
    'isInlineDiscount'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BatchTaxFiling
     */
    'isInlineVat'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'vatValue'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'documentSerialNoPrefix'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'inlineVatValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'inlineDiscountValue'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof BatchTaxFiling
     */
    'published'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BatchTaxFiling
     */
    'isVatInclusive'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'runningNumberType'?: number;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFiling
     */
    'runningModifiedOn'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'exemptAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'vatableAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'totalAfterDiscount'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'subTotal'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof BatchTaxFiling
     */
    'isReCalculate'?: boolean;
    /**
     * 
     * @type {PartialPaymentMethod}
     * @memberof BatchTaxFiling
     */
    'partialPaymentMethod'?: PartialPaymentMethod | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'vatAmount'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof BatchTaxFiling
     */
    'isMigrate'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'resetTransactionId'?: number | null;
    /**
     * 
     * @type {RuleCompileStatus}
     * @memberof BatchTaxFiling
     */
    'ruleCompileStatus'?: RuleCompileStatus;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFiling
     */
    'chequeCashingDate'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'projectId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFiling
     */
    'projectName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFiling
     */
    'projectNameAndProjectDeatil'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BatchTaxFiling
     */
    'reconciled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'outstanding'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'withholding'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFiling
     */
    'refDocumentStatus'?: number;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFiling
     */
    'refDocumentStatusString'?: string | null;
    /**
     * 
     * @type {DeductionType}
     * @memberof BatchTaxFiling
     */
    'documentDeductionType'?: DeductionType | null;
}
/**
 * 
 * @export
 * @interface BatchTaxFilingAllOf
 */
export interface BatchTaxFilingAllOf {
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'companyId': number;
    /**
     * 
     * @type {BatchTaxFilingStatus}
     * @memberof BatchTaxFilingAllOf
     */
    'status'?: BatchTaxFilingStatus;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFilingAllOf
     */
    'claimDate': string;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'totalBuyValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'totalBuyVatValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'totalSellValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'totalSellVatValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'broughtForward'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'value'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof BatchTaxFilingAllOf
     */
    'isDelete'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'createdBy'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'modifiedBy'?: number;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFilingAllOf
     */
    'createdOn': string;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFilingAllOf
     */
    'modifiedOn': string;
    /**
     * 
     * @type {Company}
     * @memberof BatchTaxFilingAllOf
     */
    'company'?: Company | null;
    /**
     * 
     * @type {User}
     * @memberof BatchTaxFilingAllOf
     */
    'createdByUser'?: User | null;
    /**
     * 
     * @type {User}
     * @memberof BatchTaxFilingAllOf
     */
    'modifiedByUser'?: User | null;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFilingAllOf
     */
    'datePayment'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'charge'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'collected'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'tax'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFilingAllOf
     */
    'remarks'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'paymentWithHeld'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'remainingCollected'?: number | null;
    /**
     * 
     * @type {RemainingCollectedType}
     * @memberof BatchTaxFilingAllOf
     */
    'remainingCollectedType'?: RemainingCollectedType | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'deductionAmount'?: number | null;
    /**
     * 
     * @type {DeductionType}
     * @memberof BatchTaxFilingAllOf
     */
    'paymentDeductionType'?: DeductionType | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'bankAccountId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFilingAllOf
     */
    'checkNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFilingAllOf
     */
    'checkBankId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFilingAllOf
     */
    'transferBankId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFilingAllOf
     */
    'bankAccountNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFilingAllOf
     */
    'checkDatePaid'?: string | null;
    /**
     * 
     * @type {PaymentMethod}
     * @memberof BatchTaxFilingAllOf
     */
    'methodPayment'?: PaymentMethod | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'no'?: number;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFilingAllOf
     */
    'pettyCashName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'pettyCashId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'chequeId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'creditCardId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'otherChannelId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFilingAllOf
     */
    'documentSerial'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFilingAllOf
     */
    'documentId'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BatchTaxFilingAllOf
     */
    'approved'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFilingAllOf
     */
    'publishedOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFilingAllOf
     */
    'documentDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'vatRate'?: number;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFilingAllOf
     */
    'dueDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFilingAllOf
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFilingAllOf
     */
    'internalNotes'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'roundingAdjustment'?: number;
    /**
     * 
     * @type {Gallery}
     * @memberof BatchTaxFilingAllOf
     */
    'gallery'?: Gallery | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'galleryId'?: number | null;
    /**
     * 
     * @type {Contact}
     * @memberof BatchTaxFilingAllOf
     */
    'contact'?: Contact | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'contactId'?: number;
    /**
     * 
     * @type {Array<IDocumentReference>}
     * @memberof BatchTaxFilingAllOf
     */
    'documentReferences'?: Array<IDocumentReference> | null;
    /**
     * 
     * @type {Array<IDocumentReference>}
     * @memberof BatchTaxFilingAllOf
     */
    'referencedToMe'?: Array<IDocumentReference> | null;
    /**
     * 
     * @type {Array<IDocumentReference>}
     * @memberof BatchTaxFilingAllOf
     */
    'referencedByMe'?: Array<IDocumentReference> | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'statusInt'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof BatchTaxFilingAllOf
     */
    'isInlineDiscount'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BatchTaxFilingAllOf
     */
    'isInlineVat'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'vatValue'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'documentSerialNoPrefix'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'inlineVatValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'inlineDiscountValue'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof BatchTaxFilingAllOf
     */
    'published'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BatchTaxFilingAllOf
     */
    'isVatInclusive'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'runningNumberType'?: number;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFilingAllOf
     */
    'runningModifiedOn'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'exemptAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'vatableAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'totalAfterDiscount'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'subTotal'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof BatchTaxFilingAllOf
     */
    'isReCalculate'?: boolean;
    /**
     * 
     * @type {PartialPaymentMethod}
     * @memberof BatchTaxFilingAllOf
     */
    'partialPaymentMethod'?: PartialPaymentMethod | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'vatAmount'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof BatchTaxFilingAllOf
     */
    'isMigrate'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'resetTransactionId'?: number | null;
    /**
     * 
     * @type {RuleCompileStatus}
     * @memberof BatchTaxFilingAllOf
     */
    'ruleCompileStatus'?: RuleCompileStatus;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFilingAllOf
     */
    'chequeCashingDate'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'projectId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFilingAllOf
     */
    'projectName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFilingAllOf
     */
    'projectNameAndProjectDeatil'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BatchTaxFilingAllOf
     */
    'reconciled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'outstanding'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'withholding'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BatchTaxFilingAllOf
     */
    'refDocumentStatus'?: number;
    /**
     * 
     * @type {string}
     * @memberof BatchTaxFilingAllOf
     */
    'refDocumentStatusString'?: string | null;
    /**
     * 
     * @type {DeductionType}
     * @memberof BatchTaxFilingAllOf
     */
    'documentDeductionType'?: DeductionType | null;
}
/**
 * 1 = Awaiting 3 = Refunded
 * @export
 * @enum {string}
 */

export const BatchTaxFilingStatus = {
    NUMBER_1: 1,
    NUMBER_3: 3
} as const;

export type BatchTaxFilingStatus = typeof BatchTaxFilingStatus[keyof typeof BatchTaxFilingStatus];


/**
 * 0 = Delete 1 = Awaiting 5 = Approved 9 = Void -9 = ResetVoid -5 = ResetApproved -1 = ResetAwaiting
 * @export
 * @enum {string}
 */

export const BookOfAccountStatus = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_5: 5,
    NUMBER_9: 9,
    NUMBER_MINUS_9: -9,
    NUMBER_MINUS_5: -5,
    NUMBER_MINUS_1: -1
} as const;

export type BookOfAccountStatus = typeof BookOfAccountStatus[keyof typeof BookOfAccountStatus];


/**
 * 1 = SellingProducts 3 = SellingServices 5 = SellingBoth 7 = Custom
 * @export
 * @enum {string}
 */

export const BusinessType = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7
} as const;

export type BusinessType = typeof BusinessType[keyof typeof BusinessType];


/**
 * 
 * @export
 * @interface ChartOfAccount
 */
export interface ChartOfAccount {
    /**
     * 
     * @type {number}
     * @memberof ChartOfAccount
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ChartOfAccount
     */
    'companyId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ChartOfAccount
     */
    'code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChartOfAccount
     */
    'nameLocal'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChartOfAccount
     */
    'nameForeign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChartOfAccount
     */
    'descriptionLocal'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChartOfAccount
     */
    'descriptionForeign'?: string | null;
    /**
     * 
     * @type {ChartOfAccountCategory}
     * @memberof ChartOfAccount
     */
    'category'?: ChartOfAccountCategory;
    /**
     * 
     * @type {number}
     * @memberof ChartOfAccount
     */
    'parentId'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ChartOfAccount
     */
    'isFolder'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ChartOfAccount
     */
    'isBank'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ChartOfAccount
     */
    'isReceivable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ChartOfAccount
     */
    'isDelete'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ChartOfAccount
     */
    'isLock'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ChartOfAccount
     */
    'createdon': string;
    /**
     * 
     * @type {string}
     * @memberof ChartOfAccount
     */
    'modifiedon': string;
    /**
     * 
     * @type {number}
     * @memberof ChartOfAccount
     */
    'modifiedby'?: number;
    /**
     * 
     * @type {number}
     * @memberof ChartOfAccount
     */
    'value'?: number;
    /**
     * 
     * @type {number}
     * @memberof ChartOfAccount
     */
    'left'?: number;
    /**
     * 
     * @type {number}
     * @memberof ChartOfAccount
     */
    'right'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ChartOfAccount
     */
    'isDefault'?: boolean;
    /**
     * 
     * @type {BankAccount}
     * @memberof ChartOfAccount
     */
    'bankAccount'?: BankAccount | null;
    /**
     * 
     * @type {PettyCash}
     * @memberof ChartOfAccount
     */
    'pettyCash'?: PettyCash | null;
    /**
     * 
     * @type {Cheque}
     * @memberof ChartOfAccount
     */
    'cheque'?: Cheque | null;
    /**
     * 
     * @type {CreditCard}
     * @memberof ChartOfAccount
     */
    'creditCard'?: CreditCard | null;
    /**
     * 
     * @type {OtherChannels}
     * @memberof ChartOfAccount
     */
    'otherChannels'?: OtherChannels | null;
    /**
     * 
     * @type {SystemChartOfAccount}
     * @memberof ChartOfAccount
     */
    'systemChartOfAccount'?: SystemChartOfAccount | null;
}
/**
 * 1 = Assets 2 = Liabilities 3 = Equity 4 = Revenue 5 = Expenses
 * @export
 * @enum {string}
 */

export const ChartOfAccountCategory = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5
} as const;

export type ChartOfAccountCategory = typeof ChartOfAccountCategory[keyof typeof ChartOfAccountCategory];


/**
 * 
 * @export
 * @interface Cheque
 */
export interface Cheque {
    /**
     * 
     * @type {number}
     * @memberof Cheque
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Cheque
     */
    'companyId': number;
    /**
     * 
     * @type {number}
     * @memberof Cheque
     */
    'bankAccountId'?: number;
    /**
     * 
     * @type {BankAccount}
     * @memberof Cheque
     */
    'bankAccount'?: BankAccount | null;
    /**
     * 
     * @type {number}
     * @memberof Cheque
     */
    'chartOfAccountId'?: number | null;
    /**
     * 
     * @type {ChartOfAccount}
     * @memberof Cheque
     */
    'chartOfAccount'?: ChartOfAccount | null;
    /**
     * 
     * @type {BankingChannelsStatus}
     * @memberof Cheque
     */
    'status'?: BankingChannelsStatus;
    /**
     * 
     * @type {boolean}
     * @memberof Cheque
     */
    'isDelete'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Cheque
     */
    'createdOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof Cheque
     */
    'modifiedOn'?: string;
}
/**
 * 
 * @export
 * @interface Company
 */
export interface Company {
    /**
     * 
     * @type {number}
     * @memberof Company
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'nameLocal': string;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'nameForeign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'addressLocal'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'addressForeign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'companyTaxId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'logoImage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'fax'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'phone1'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'phone2'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'phone3'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'websites'?: string | null;
    /**
     * 
     * @type {CompanyTypeEnum}
     * @memberof Company
     */
    'companyType'?: CompanyTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'createdOn': string;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'modifiedOn': string;
    /**
     * 
     * @type {boolean}
     * @memberof Company
     */
    'isDefault'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'addressLocalLine2'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'addressForeignLine2'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Company
     */
    'vatRate'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Company
     */
    'isVat'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'branch'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'addressLocalLine3'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'addressForeignLine3'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'contactPerson'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Company
     */
    'isActive'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'remarks'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Company
     */
    'galleryId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'branchForeign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'branchCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Company
     */
    'contactType': number;
    /**
     * 
     * @type {number}
     * @memberof Company
     */
    'defaultCreditDays'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Company
     */
    'logoType': number;
    /**
     * 
     * @type {boolean}
     * @memberof Company
     */
    'isRegistered'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Company
     */
    'isAdvance': boolean;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'address'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Company
     */
    'provinceId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Company
     */
    'amphurId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Company
     */
    'districtId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'zipCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'supportCode'?: string | null;
    /**
     * 
     * @type {SalesType}
     * @memberof Company
     */
    'salesType'?: SalesType | null;
    /**
     * 
     * @type {CompanyPreferences}
     * @memberof Company
     */
    'companyPreferences'?: CompanyPreferences | null;
    /**
     * 
     * @type {PayrollPreferences}
     * @memberof Company
     */
    'payrollPreferences'?: PayrollPreferences | null;
    /**
     * 
     * @type {Array<CompanySubscription>}
     * @memberof Company
     */
    'companySubscription'?: Array<CompanySubscription> | null;
}
/**
 * 
 * @export
 * @interface CompanyExpenseCategory
 */
export interface CompanyExpenseCategory {
    /**
     * 
     * @type {number}
     * @memberof CompanyExpenseCategory
     */
    'companyId'?: number;
    /**
     * 
     * @type {number}
     * @memberof CompanyExpenseCategory
     */
    'expenseCategoryId'?: number;
    /**
     * 
     * @type {Company}
     * @memberof CompanyExpenseCategory
     */
    'company'?: Company | null;
    /**
     * 
     * @type {ExpenseCategory}
     * @memberof CompanyExpenseCategory
     */
    'expenseCategory'?: ExpenseCategory | null;
}
/**
 * 
 * @export
 * @interface CompanyPreferences
 */
export interface CompanyPreferences {
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'companyId'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CompanyPreferences
     */
    'showWithHolding'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'invoicePrefix': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'quotationPrefix': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'billingNotePrefix': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'receiptPrefix': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'purchaseOrderPrefix': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'cashInvoicePrefix': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'receivableInvoicePrefix': string;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'cashInvoiceStartingNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'receiptStartingNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'quotationStartingNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'billingNoteStartingNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'purchaseOrderStartingNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'purchaseOrderTitleEN': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'quotationTitleEN': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'billingNoteTitleEN': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'invoiceTitleEN': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'receiptTitleEN': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'paymentSlipTitleEN': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'purchaseOrderTitleTH': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'quotationTitleTH': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'billingNoteTitleTH': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'invoiceTitleTH': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'receiptTitleTH': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'paymentSlipTitleTH': string;
    /**
     * 
     * @type {BusinessType}
     * @memberof CompanyPreferences
     */
    'businessType'?: BusinessType;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'termsAgreement'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'defaultRemarks'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'invoiceStartingNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'cashInvoiceTitleEN': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'cashInvoiceTitleTH': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'receivableInvoiceTitleTH': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'receivableInvoiceTitleEN': string;
    /**
     * 
     * @type {RunningNumberType}
     * @memberof CompanyPreferences
     */
    'runningNumberType'?: RunningNumberType;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'purchaseOrderStartingYear'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'quotationStartingYear'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'billingNoteStartingYear'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'invoiceStartingYear'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'cashInvoiceStartingYear'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'receiptStartingYear'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'purchaseOrderStartingMonth'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'quotationStartingMonth'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'billingNoteStartingMonth'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'invoiceStartingMonth'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'cashInvoiceStartingMonth'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'receiptStartingMonth'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof CompanyPreferences
     */
    'settingsInitiated'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'runningNumberSettingsModifiedOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'withHoldingTaxPrefix': string;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'withHoldingTaxStartingNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'withHoldingTaxStartingMonth'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'withHoldingTaxStartingYear'?: number | null;
    /**
     * 
     * @type {DocumentTemplates}
     * @memberof CompanyPreferences
     */
    'documentTemplates'?: DocumentTemplates;
    /**
     * 
     * @type {boolean}
     * @memberof CompanyPreferences
     */
    'printColor'?: boolean;
    /**
     * 
     * @type {TemplateFont}
     * @memberof CompanyPreferences
     */
    'templateFont'?: TemplateFont;
    /**
     * 
     * @type {boolean}
     * @memberof CompanyPreferences
     */
    'printOneInvoice'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'remarks'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'emailMessageTemplate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'purchasePrefix': string;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'purchaseStartingNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'purchaseTitleEN': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'purchaseTitleTH': string;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'purchaseStartingYear'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'purchaseStartingMonth'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'adjustInventoryPrefix': string;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'adjustInventoryStartingNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'adjustInventoryStartingMonth'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'adjustInventoryStartingYear'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'expensePrefix': string;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'expenseStartingNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'expenseStartingMonth'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'expenseStartingYear'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'paymentSlipPrefix': string;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'paymentSlipStartingNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'paymentSlipStartingYear'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'paymentSlipStartingMonth'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'cashInvoiceRunningNumberModifiedOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'purchaseOrderRunningNumberModifiedOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'quotationRunningNumberModifiedOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'billingNoteRunningNumberModifiedOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'invoiceRunningNumberModifiedOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'purchaseRunningNumberModifiedOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'receivableInvoiceRunningNumberModifiedOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'paymentSlipRunningNumberModifiedOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'rubberStampUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'creditNotePrefix': string;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'creditNoteStartingNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'creditNoteStartingMonth'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'creditNoteStartingYear'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'creditNoteRunningNumberModifiedOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'creditNoteTitleEN': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'creditNoteTitleTH': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'debitNotePrefix': string;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'debitNoteStartingNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'debitNoteStartingMonth'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'debitNoteStartingYear'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'debitNoteRunningNumberModifiedOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'debitNoteTitleEN': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'debitNoteTitleTH': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'receiptRunningNumberModifiedOn'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'receivableInvoiceStartingNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'receivableInvoiceStartingMonth'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'receivableInvoiceStartingYear'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof CompanyPreferences
     */
    'usePartialReceipt'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CompanyPreferences
     */
    'useCashInvoice'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CompanyPreferences
     */
    'useShortCashInvoice'?: boolean;
    /**
     * 
     * @type {RunningNumberType}
     * @memberof CompanyPreferences
     */
    'generalLedgerRunningNumberType'?: RunningNumberType;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'journalVoucherPrefix': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'purchaseVoucherPrefix': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'purchaseVoucherRunningNumberModifiedOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'salesVoucherPrefix': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'salesVoucherRunningNumberModifiedOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'paymentVoucherPrefix': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'paymentVoucherRunningNumberModifiedOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'receivedVoucherPrefix': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'receivedVoucherRunningNumberModifiedOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'conversionBalancePrefix': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'conversionBalanceRunningNumberModifiedOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'eTaxEmail'?: string | null;
    /**
     * 
     * @type {DocumentTemplates}
     * @memberof CompanyPreferences
     */
    'shortCashInvoiceTemplates'?: DocumentTemplates;
    /**
     * 
     * @type {boolean}
     * @memberof CompanyPreferences
     */
    'useBillingNoteAccountingRule'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'billingNoteAccountingRuleModifiedOn'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CompanyPreferences
     */
    'templateFontSize'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof CompanyPreferences
     */
    'useMultiCurrency'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'expenseTitleTH'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'expenseTitleEN'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'withHoldingTaxTitleTH'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyPreferences
     */
    'withHoldingTaxTitleEN'?: string | null;
}
/**
 * 
 * @export
 * @interface CompanySubscription
 */
export interface CompanySubscription {
    /**
     * 
     * @type {number}
     * @memberof CompanySubscription
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof CompanySubscription
     */
    'companyId'?: number;
    /**
     * 
     * @type {number}
     * @memberof CompanySubscription
     */
    'packageId'?: number;
    /**
     * 
     * @type {PackageStatus}
     * @memberof CompanySubscription
     */
    'packageStatus'?: PackageStatus;
    /**
     * 
     * @type {string}
     * @memberof CompanySubscription
     */
    'transactionDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof CompanySubscription
     */
    'transactionId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanySubscription
     */
    'expirationDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof CompanySubscription
     */
    'couponId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CompanySubscription
     */
    'paidBy'?: number;
    /**
     * 
     * @type {string}
     * @memberof CompanySubscription
     */
    'createdOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof CompanySubscription
     */
    'modifiedOn'?: string;
    /**
     * 
     * @type {number}
     * @memberof CompanySubscription
     */
    'days'?: number;
    /**
     * 
     * @type {number}
     * @memberof CompanySubscription
     */
    'packageDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof CompanySubscription
     */
    'quantity'?: number | null;
    /**
     * 
     * @type {UpgradeType}
     * @memberof CompanySubscription
     */
    'type'?: UpgradeType;
    /**
     * 
     * @type {PaymentChannel}
     * @memberof CompanySubscription
     */
    'paymentChannel'?: PaymentChannel | null;
    /**
     * 
     * @type {number}
     * @memberof CompanySubscription
     */
    'value'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof CompanySubscription
     */
    'isWithheld'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CompanySubscription
     */
    'withheld'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CompanySubscription
     */
    'internalFile'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CompanySubscription
     */
    'invoiceId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CompanySubscription
     */
    'remarks'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof CompanySubscription
     */
    'isRequestInvoice'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof CompanySubscription
     */
    'addOn'?: string | null;
    /**
     * 
     * @type {PackageList}
     * @memberof CompanySubscription
     */
    'packageList'?: PackageList | null;
    /**
     * 
     * @type {string}
     * @memberof CompanySubscription
     */
    'paySlipImageDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanySubscription
     */
    'paySlipImageTime'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CompanySubscription
     */
    'paySlipImageAmount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CompanySubscription
     */
    'paySlipImageContact'?: string | null;
}
/**
 * 10 = PrivateWithTax 20 = PrivateWithoutTax 30 = Personal 40 = PersonalWithTax 50 = PartnershipLimitedWithTax 60 = PartnershipLimitedWithoutTax
 * @export
 * @enum {string}
 */

export const CompanyTypeEnum = {
    NUMBER_10: 10,
    NUMBER_20: 20,
    NUMBER_30: 30,
    NUMBER_40: 40,
    NUMBER_50: 50,
    NUMBER_60: 60
} as const;

export type CompanyTypeEnum = typeof CompanyTypeEnum[keyof typeof CompanyTypeEnum];


/**
 * 1 = WithholdsTaxAtSource 2 = PayEveryTime 3 = PayOneTime
 * @export
 * @enum {string}
 */

export const ConditionsOfWithholdingTax = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;

export type ConditionsOfWithholdingTax = typeof ConditionsOfWithholdingTax[keyof typeof ConditionsOfWithholdingTax];


/**
 * 
 * @export
 * @interface Contact
 */
export interface Contact {
    /**
     * 
     * @type {number}
     * @memberof Contact
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'nameLocal'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'nameForeign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'addressLocal'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'addressForeign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'addressLocalLine2'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'addressForeignLine2'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'addressLocalLine3'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'addressForeignLine3'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'branch'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'branchForeign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'companyTaxId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'fax'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'phone1'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'phone2'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'phone3'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'websites'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'createdOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'modifiedOn'?: string;
    /**
     * 
     * @type {number}
     * @memberof Contact
     */
    'modifiedBy'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Contact
     */
    'isDelete'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Contact
     */
    'isDefault'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'logoImage'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Contact
     */
    'defaultCreditDays'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Contact
     */
    'vatRate'?: number;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'contactPerson'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Contact
     */
    'isActive'?: boolean;
    /**
     * 
     * @type {ContactTypes}
     * @memberof Contact
     */
    'contactType'?: ContactTypes;
    /**
     * 
     * @type {ContactGroups}
     * @memberof Contact
     */
    'contactGroup'?: ContactGroups;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'remarks'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Contact
     */
    'galleryId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'branchCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'transactionId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Contact
     */
    'resetTransactionId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'contactCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'internalNotes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'shippingAddress'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'zipCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'swiftCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'bankAddress'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Contact
     */
    'useForeignBank'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof Contact
     */
    'isMigrate'?: boolean;
}
/**
 * 1 = Individual 3 = Juristic 9 = Undefined
 * @export
 * @enum {string}
 */

export const ContactGroups = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_9: 9
} as const;

export type ContactGroups = typeof ContactGroups[keyof typeof ContactGroups];


/**
 * 
 * @export
 * @interface ContactResult
 */
export interface ContactResult {
    /**
     * 
     * @type {number}
     * @memberof ContactResult
     */
    'id'?: number;
    /**
     * 
     * @type {ContactTypes}
     * @memberof ContactResult
     */
    'contactType'?: ContactTypes;
    /**
     * 
     * @type {string}
     * @memberof ContactResult
     */
    'code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactResult
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactResult
     */
    'addressLocal'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactResult
     */
    'addressLocalLine2'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactResult
     */
    'addressLocalLine3'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactResult
     */
    'taxId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactResult
     */
    'branch'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactResult
     */
    'branchCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactResult
     */
    'contactPerson'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactResult
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactResult
     */
    'mobile'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ContactResult
     */
    'defaultCreditDays'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ContactResult
     */
    'office'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactResult
     */
    'fax'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactResult
     */
    'website'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactResult
     */
    'shippingAddress'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactResult
     */
    'internalNotes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactResult
     */
    'remarks'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactResult
     */
    'zipCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ContactResult
     */
    'bankId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ContactResult
     */
    'bankName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactResult
     */
    'bankBranch'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactResult
     */
    'bankAccountNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactResult
     */
    'swiftCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactResult
     */
    'bankAddress'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ContactResult
     */
    'useForeignBank'?: boolean;
    /**
     * 
     * @type {BankAccountType}
     * @memberof ContactResult
     */
    'bankAccountType'?: BankAccountType | null;
    /**
     * 
     * @type {ContactGroups}
     * @memberof ContactResult
     */
    'contactGroup'?: ContactGroups;
    /**
     * 
     * @type {Array<Media>}
     * @memberof ContactResult
     */
    'media'?: Array<Media> | null;
    /**
     * 
     * @type {Media}
     * @memberof ContactResult
     */
    'qrCode'?: Media | null;
}
/**
 * 0 = OwnCompany 3 = Client 5 = Vendor 7 = VendorAndClient 9 = ExpenseVendor
 * @export
 * @enum {string}
 */

export const ContactTypes = {
    NUMBER_0: 0,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7,
    NUMBER_9: 9
} as const;

export type ContactTypes = typeof ContactTypes[keyof typeof ContactTypes];


/**
 * 
 * @export
 * @interface CreditCard
 */
export interface CreditCard {
    /**
     * 
     * @type {number}
     * @memberof CreditCard
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreditCard
     */
    'companyId': number;
    /**
     * 
     * @type {number}
     * @memberof CreditCard
     */
    'chartOfAccountId'?: number | null;
    /**
     * 
     * @type {ChartOfAccount}
     * @memberof CreditCard
     */
    'chartOfAccount'?: ChartOfAccount | null;
    /**
     * 
     * @type {number}
     * @memberof CreditCard
     */
    'bankId'?: number;
    /**
     * 
     * @type {Bank}
     * @memberof CreditCard
     */
    'bank'?: Bank | null;
    /**
     * 
     * @type {string}
     * @memberof CreditCard
     */
    'bankName'?: string | null;
    /**
     * 
     * @type {CreditCardType}
     * @memberof CreditCard
     */
    'type'?: CreditCardType;
    /**
     * 
     * @type {string}
     * @memberof CreditCard
     */
    'cardNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreditCard
     */
    'cardHolderName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreditCard
     */
    'cardName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CreditCard
     */
    'cashLimit'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreditCard
     */
    'statementDate'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreditCard
     */
    'dueDate'?: number;
    /**
     * 
     * @type {BankingChannelsStatus}
     * @memberof CreditCard
     */
    'status'?: BankingChannelsStatus;
    /**
     * 
     * @type {boolean}
     * @memberof CreditCard
     */
    'isDelete'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreditCard
     */
    'createdOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreditCard
     */
    'modifiedOn'?: string;
}
/**
 * 1 = Personal 3 = Business
 * @export
 * @enum {string}
 */

export const CreditCardType = {
    NUMBER_1: 1,
    NUMBER_3: 3
} as const;

export type CreditCardType = typeof CreditCardType[keyof typeof CreditCardType];


/**
 * 1 = USD 3 = GBP 5 = EUR 7 = JPY 9 = HKD 11 = CNY 13 = THB 15 = AUD 33 = BDT 35 = BHD 37 = BND 39 = KHR 41 = CAD 43 = DKK 45 = INR 47 = IDR 49 = ILS 53 = KRW 55 = LAK 57 = MOP 59 = MYR 61 = MMK 63 = NPR 65 = NZD 67 = NOK 69 = OMR 71 = PKR 73 = PHP 75 = QAR 77 = RUB 79 = SAR 81 = SEK 83 = SGD 85 = LKR 87 = CHF 89 = TWD 91 = AED 93 = VND 95 = ZAR 97 = MXN 99 = KWD 101 = CZK 103 = KES 105 = EGP 107 = PLN 109 = IQD 111 = JOD 113 = MVR 115 = PGK 117 = HUF
 * @export
 * @enum {string}
 */

export const Currency = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7,
    NUMBER_9: 9,
    NUMBER_11: 11,
    NUMBER_13: 13,
    NUMBER_15: 15,
    NUMBER_33: 33,
    NUMBER_35: 35,
    NUMBER_37: 37,
    NUMBER_39: 39,
    NUMBER_41: 41,
    NUMBER_43: 43,
    NUMBER_45: 45,
    NUMBER_47: 47,
    NUMBER_49: 49,
    NUMBER_53: 53,
    NUMBER_55: 55,
    NUMBER_57: 57,
    NUMBER_59: 59,
    NUMBER_61: 61,
    NUMBER_63: 63,
    NUMBER_65: 65,
    NUMBER_67: 67,
    NUMBER_69: 69,
    NUMBER_71: 71,
    NUMBER_73: 73,
    NUMBER_75: 75,
    NUMBER_77: 77,
    NUMBER_79: 79,
    NUMBER_81: 81,
    NUMBER_83: 83,
    NUMBER_85: 85,
    NUMBER_87: 87,
    NUMBER_89: 89,
    NUMBER_91: 91,
    NUMBER_93: 93,
    NUMBER_95: 95,
    NUMBER_97: 97,
    NUMBER_99: 99,
    NUMBER_101: 101,
    NUMBER_103: 103,
    NUMBER_105: 105,
    NUMBER_107: 107,
    NUMBER_109: 109,
    NUMBER_111: 111,
    NUMBER_113: 113,
    NUMBER_115: 115,
    NUMBER_117: 117
} as const;

export type Currency = typeof Currency[keyof typeof Currency];


/**
 * 1 = SwitchProductItemSellToBuy
 * @export
 * @enum {string}
 */

export const CustomDocumentModel = {
    NUMBER_1: 1
} as const;

export type CustomDocumentModel = typeof CustomDocumentModel[keyof typeof CustomDocumentModel];


/**
 * 
 * @export
 * @interface CustomTemplate
 */
export interface CustomTemplate {
    /**
     * 
     * @type {number}
     * @memberof CustomTemplate
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CustomTemplate
     */
    'name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CustomTemplate
     */
    'sheetIndex'?: number;
    /**
     * 
     * @type {any}
     * @memberof CustomTemplate
     */
    'columns'?: any | null;
    /**
     * 
     * @type {DateInfo}
     * @memberof CustomTemplate
     */
    'dateFormat'?: DateInfo | null;
    /**
     * 
     * @type {boolean}
     * @memberof CustomTemplate
     */
    'ignoreLastRow'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CustomTemplate
     */
    'imageUrl'?: string | null;
    /**
     * 
     * @type {CustomTemplateInfo}
     * @memberof CustomTemplate
     */
    'customTemplateInfo'?: CustomTemplateInfo | null;
    /**
     * 
     * @type {any}
     * @memberof CustomTemplate
     */
    'formulas'?: any | null;
}
/**
 * 
 * @export
 * @interface CustomTemplateInfo
 */
export interface CustomTemplateInfo {
    /**
     * 
     * @type {string}
     * @memberof CustomTemplateInfo
     */
    'headerIndex'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CustomTemplateInfo
     */
    'productName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CustomTemplateInfo
     */
    'includeTax'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof CustomTemplateInfo
     */
    'isChooseDateColumn'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CustomTemplateInfo
     */
    'isChooseUnitPriceColumn'?: boolean;
    /**
     * 
     * @type {Array<object>}
     * @memberof CustomTemplateInfo
     */
    'columns'?: Array<object> | null;
}
/**
 * 1 = CurrentMonth 3 = PreviousMonth 5 = Manual 7 = CurrentYear 9 = PreviousYear 11 = AsAt 13 = Grid 15 = FiscalYear 17 = Months 19 = Days
 * @export
 * @enum {string}
 */

export const DataRange = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7,
    NUMBER_9: 9,
    NUMBER_11: 11,
    NUMBER_13: 13,
    NUMBER_15: 15,
    NUMBER_17: 17,
    NUMBER_19: 19
} as const;

export type DataRange = typeof DataRange[keyof typeof DataRange];


/**
 * 
 * @export
 * @interface DateInfo
 */
export interface DateInfo {
    /**
     * 
     * @type {string}
     * @memberof DateInfo
     */
    'format'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DateInfo
     */
    'type'?: string | null;
}
/**
 * 1 = PublishDate 3 = PaymentDate 5 = ExpenseDate 7 = TransitionDate
 * @export
 * @enum {string}
 */

export const DateType = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7
} as const;

export type DateType = typeof DateType[keyof typeof DateType];


/**
 * 0 = None 1 = CashDiscount 3 = Commission 5 = ManagementFee 7 = Roundings 9 = Retentions
 * @export
 * @enum {string}
 */

export const DeductionType = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7,
    NUMBER_9: 9
} as const;

export type DeductionType = typeof DeductionType[keyof typeof DeductionType];


/**
 * 
 * @export
 * @interface Department
 */
export interface Department {
    /**
     * 
     * @type {number}
     * @memberof Department
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Department
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Department
     */
    'code'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Department
     */
    'isDelete'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Department
     */
    'companyId'?: number;
    /**
     * 
     * @type {number}
     * @memberof Department
     */
    'createdBy'?: number;
    /**
     * 
     * @type {number}
     * @memberof Department
     */
    'modifiedBy'?: number;
    /**
     * 
     * @type {string}
     * @memberof Department
     */
    'createdOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof Department
     */
    'modifiedOn'?: string;
    /**
     * 
     * @type {Company}
     * @memberof Department
     */
    'company'?: Company | null;
    /**
     * 
     * @type {Array<Employee>}
     * @memberof Department
     */
    'employees'?: Array<Employee> | null;
}
/**
 * 
 * @export
 * @interface Document
 */
export interface Document {
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'recordId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'contactCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'contactName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'contactAddress'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'contactTaxId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'contactBranch'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'contactPerson'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'contactEmail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'contactNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'contactZipCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'contactGroup'?: number;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'publishedOn'?: string;
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'creditType'?: number;
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'creditDays'?: number;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'dueDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'salesName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'projectName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'reference'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Document
     */
    'isVatInclusive'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Document
     */
    'useReceiptDeduction'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'subTotal'?: number;
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'discountPercentage'?: number;
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'discountAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'totalAfterDiscount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Document
     */
    'isVat'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'vatAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'grandTotal'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Document
     */
    'documentShowWithholdingTax'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'documentWithholdingTaxPercentage'?: number;
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'documentWithholdingTaxAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'documentDeductionType'?: number;
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'documentDeductionAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'remarks'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'internalNotes'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Document
     */
    'showSignatureOrStamp'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'documentStructureType'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'externalId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'saleAndPurchaseChannel'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'rowIndex'?: string | null;
}
/**
 * 
 * @export
 * @interface DocumentQuery
 */
export interface DocumentQuery {
    /**
     * 
     * @type {number}
     * @memberof DocumentQuery
     */
    'pageSize'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentQuery
     */
    'currentPage'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentQuery
     */
    'totalRecords'?: number;
    /**
     * 
     * @type {DateType}
     * @memberof DocumentQuery
     */
    'dateType'?: DateType;
    /**
     * 
     * @type {string}
     * @memberof DocumentQuery
     */
    'startDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentQuery
     */
    'endDate'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentQuery
     */
    'day'?: number;
    /**
     * 
     * @type {number}
     * @memberof DocumentQuery
     */
    'month'?: number;
    /**
     * 
     * @type {number}
     * @memberof DocumentQuery
     */
    'year'?: number;
    /**
     * 
     * @type {DataRange}
     * @memberof DocumentQuery
     */
    'range'?: DataRange;
    /**
     * 
     * @type {number}
     * @memberof DocumentQuery
     */
    'isFirstCurrent'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof DocumentQuery
     */
    'hashTags'?: Array<string> | null;
    /**
     * 
     * @type {ReportTypes}
     * @memberof DocumentQuery
     */
    'reportType'?: ReportTypes;
    /**
     * 
     * @type {Array<FilterOptions>}
     * @memberof DocumentQuery
     */
    'filter'?: Array<FilterOptions> | null;
    /**
     * 
     * @type {Array<SortOptions>}
     * @memberof DocumentQuery
     */
    'sortBy'?: Array<SortOptions> | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentQuery
     */
    'totalValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof DocumentQuery
     */
    'totalVAT'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DocumentQuery
     */
    'isReceived'?: boolean;
    /**
     * 
     * @type {Array<DocumentTypes>}
     * @memberof DocumentQuery
     */
    'documentType'?: Array<DocumentTypes> | null;
    /**
     * 
     * @type {Array<ListItem>}
     * @memberof DocumentQuery
     */
    'revenue'?: Array<ListItem> | null;
    /**
     * 
     * @type {Array<ListItem>}
     * @memberof DocumentQuery
     */
    'expenses'?: Array<ListItem> | null;
    /**
     * 
     * @type {Array<ListItem>}
     * @memberof DocumentQuery
     */
    'previousMonths'?: Array<ListItem> | null;
    /**
     * 
     * @type {Array<ListItem>}
     * @memberof DocumentQuery
     */
    'previousYears'?: Array<ListItem> | null;
    /**
     * 
     * @type {Array<CustomDocumentModel>}
     * @memberof DocumentQuery
     */
    'customDocumentModels'?: Array<CustomDocumentModel> | null;
}
/**
 * 
 * @export
 * @interface DocumentQueryAllOf
 */
export interface DocumentQueryAllOf {
    /**
     * 
     * @type {number}
     * @memberof DocumentQueryAllOf
     */
    'totalValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof DocumentQueryAllOf
     */
    'totalVAT'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DocumentQueryAllOf
     */
    'isReceived'?: boolean;
    /**
     * 
     * @type {Array<DocumentTypes>}
     * @memberof DocumentQueryAllOf
     */
    'documentType'?: Array<DocumentTypes> | null;
    /**
     * 
     * @type {Array<ListItem>}
     * @memberof DocumentQueryAllOf
     */
    'revenue'?: Array<ListItem> | null;
    /**
     * 
     * @type {Array<ListItem>}
     * @memberof DocumentQueryAllOf
     */
    'expenses'?: Array<ListItem> | null;
    /**
     * 
     * @type {Array<ListItem>}
     * @memberof DocumentQueryAllOf
     */
    'previousMonths'?: Array<ListItem> | null;
    /**
     * 
     * @type {Array<ListItem>}
     * @memberof DocumentQueryAllOf
     */
    'previousYears'?: Array<ListItem> | null;
    /**
     * 
     * @type {Array<CustomDocumentModel>}
     * @memberof DocumentQueryAllOf
     */
    'customDocumentModels'?: Array<CustomDocumentModel> | null;
}
/**
 * 1 = ImportDocument 3 = PartialPayments 5 = Batch 7 = Etax 9 = MiigratePartialPayments 11 = BatchPartialPayments 13 = DepositFirst 15 = DepositLast
 * @export
 * @enum {string}
 */

export const DocumentReferenceTypes = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7,
    NUMBER_9: 9,
    NUMBER_11: 11,
    NUMBER_13: 13,
    NUMBER_15: 15
} as const;

export type DocumentReferenceTypes = typeof DocumentReferenceTypes[keyof typeof DocumentReferenceTypes];


/**
 * 1 = Default 3 = Template1 5 = Template2 7 = Template3 9 = Template4 11 = Template5 13 = TemplateA5 15 = Template9x11withOriginal 17 = Template8 101 = NativeDefault 103 = Native1 105 = Native3 107 = Native5 109 = Native7 111 = Native9 113 = Native11 115 = Native13 201 = Thermal1 203 = Thermal2 205 = SocialSlip 301 = ShortCA1 303 = ShortCA2 305 = ShortCA3
 * @export
 * @enum {string}
 */

export const DocumentTemplates = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7,
    NUMBER_9: 9,
    NUMBER_11: 11,
    NUMBER_13: 13,
    NUMBER_15: 15,
    NUMBER_17: 17,
    NUMBER_101: 101,
    NUMBER_103: 103,
    NUMBER_105: 105,
    NUMBER_107: 107,
    NUMBER_109: 109,
    NUMBER_111: 111,
    NUMBER_113: 113,
    NUMBER_115: 115,
    NUMBER_201: 201,
    NUMBER_203: 203,
    NUMBER_205: 205,
    NUMBER_301: 301,
    NUMBER_303: 303,
    NUMBER_305: 305
} as const;

export type DocumentTemplates = typeof DocumentTemplates[keyof typeof DocumentTemplates];


/**
 * 1 = PurchaseOrder 3 = Quotation 5 = BillingNote 7 = TaxInvoice 9 = Receipt 13 = Expense 15 = Vendor 17 = WithHoldingTax 19 = BillingNotePartials 21 = TaxInvoicePartails 23 = Purchase 24 = PurchaseTax 25 = ReceivableInvoice 29 = AdjustInventory 31 = CreditNote 33 = DebitNote 35 = CashInvoice 37 = PaymentSlip 51 = JournalEntry 53 = PurchaseVoucher 55 = SalesVoucher 57 = PaymentVoucher 59 = ReceivedVoucher 61 = ConversionBalance 63 = Transaction 65 = SupplierInvoice 67 = BatchTaxFiling 69 = FixedAsset 71 = Depreciation 73 = BankTransfer 151 = DraftJournalEntry 153 = DraftPurchaseVoucher 155 = DraftSalesVoucher 157 = DraftPaymentVoucher 159 = DraftReceivedVoucher 201 = Payroll 202 = PayrollDetail 203 = Employee 204 = PayrollPayment
 * @export
 * @enum {string}
 */

export const DocumentTypes = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7,
    NUMBER_9: 9,
    NUMBER_13: 13,
    NUMBER_15: 15,
    NUMBER_17: 17,
    NUMBER_19: 19,
    NUMBER_21: 21,
    NUMBER_23: 23,
    NUMBER_24: 24,
    NUMBER_25: 25,
    NUMBER_29: 29,
    NUMBER_31: 31,
    NUMBER_33: 33,
    NUMBER_35: 35,
    NUMBER_37: 37,
    NUMBER_51: 51,
    NUMBER_53: 53,
    NUMBER_55: 55,
    NUMBER_57: 57,
    NUMBER_59: 59,
    NUMBER_61: 61,
    NUMBER_63: 63,
    NUMBER_65: 65,
    NUMBER_67: 67,
    NUMBER_69: 69,
    NUMBER_71: 71,
    NUMBER_73: 73,
    NUMBER_151: 151,
    NUMBER_153: 153,
    NUMBER_155: 155,
    NUMBER_157: 157,
    NUMBER_159: 159,
    NUMBER_201: 201,
    NUMBER_202: 202,
    NUMBER_203: 203,
    NUMBER_204: 204
} as const;

export type DocumentTypes = typeof DocumentTypes[keyof typeof DocumentTypes];


/**
 * 
 * @export
 * @interface Employee
 */
export interface Employee {
    /**
     * 
     * @type {number}
     * @memberof Employee
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Employee
     */
    'companyId'?: number | null;
    /**
     * 
     * @type {GenderPrefix}
     * @memberof Employee
     */
    'prefix'?: GenderPrefix;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'firstName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'lastName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Employee
     */
    'salary'?: number;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'identitficationNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'passportNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'profileImage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'mobile'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Employee
     */
    'commission'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'remarks'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'title'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Employee
     */
    'galleryId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Employee
     */
    'bankId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'branch'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'accountNumber'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Employee
     */
    'accountType'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'startDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'endDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'internalNote'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Employee
     */
    'isActive'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'createdOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'modifiedOn'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Employee
     */
    'createdBy'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Employee
     */
    'modifiedBy'?: number | null;
    /**
     * 
     * @type {EmployeeTypes}
     * @memberof Employee
     */
    'type'?: EmployeeTypes | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'code'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Employee
     */
    'salaryType'?: number;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'socialSecurityNumber'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Employee
     */
    'employerSocialSecurityRate'?: number;
    /**
     * 
     * @type {number}
     * @memberof Employee
     */
    'employeeSocialSecurityRate'?: number;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'dob'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'address'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'contactName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'contactNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'contactRelationship'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'office'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Employee
     */
    'socialSecurityStatus'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Employee
     */
    'methodPayment'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'secondaryEmail'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Employee
     */
    'isDelete'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Employee
     */
    'socialSecurityValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof Employee
     */
    'withholdingTax'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Employee
     */
    'isHeadOffice'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'companyBranch'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Employee
     */
    'maritalStatus'?: number;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'currentAddress'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Employee
     */
    'departmentId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'firstNameForeign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'lastNameForeign'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Employee
     */
    'isSocialSecurityRegistered'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'bankBranchCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Employee
     */
    'idCard'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Employee
     */
    'householdRegistration'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'nickname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'nicknameForeign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'lineId'?: string | null;
    /**
     * 
     * @type {ConditionsOfWithholdingTax}
     * @memberof Employee
     */
    'conditionsWithholdingTax'?: ConditionsOfWithholdingTax | null;
    /**
     * 
     * @type {PaidPeriod}
     * @memberof Employee
     */
    'paidPeriod'?: PaidPeriod;
    /**
     * 
     * @type {Bank}
     * @memberof Employee
     */
    'bank'?: Bank | null;
    /**
     * 
     * @type {Company}
     * @memberof Employee
     */
    'company'?: Company | null;
    /**
     * 
     * @type {Gallery}
     * @memberof Employee
     */
    'gallery'?: Gallery | null;
    /**
     * 
     * @type {Gallery}
     * @memberof Employee
     */
    'galleryIdCard'?: Gallery | null;
    /**
     * 
     * @type {Gallery}
     * @memberof Employee
     */
    'galleryHouseholdRegistration'?: Gallery | null;
    /**
     * 
     * @type {Array<PayrollDetail>}
     * @memberof Employee
     */
    'payrollDetail'?: Array<PayrollDetail> | null;
    /**
     * 
     * @type {Department}
     * @memberof Employee
     */
    'department'?: Department | null;
}
/**
 * 
 * @export
 * @interface EmployeeModel
 */
export interface EmployeeModel {
    /**
     * 
     * @type {number}
     * @memberof EmployeeModel
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof EmployeeModel
     */
    'companyId'?: number | null;
    /**
     * 
     * @type {GenderPrefix}
     * @memberof EmployeeModel
     */
    'prefix'?: GenderPrefix;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'firstName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'lastName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EmployeeModel
     */
    'salary'?: number;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'identitficationNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'passportNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'profileImage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'mobile'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EmployeeModel
     */
    'commission'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'remarks'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'title'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EmployeeModel
     */
    'galleryId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof EmployeeModel
     */
    'bankId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'branch'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'accountNumber'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EmployeeModel
     */
    'accountType'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'startDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'endDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'internalNote'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof EmployeeModel
     */
    'isActive'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'createdOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'modifiedOn'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EmployeeModel
     */
    'createdBy'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof EmployeeModel
     */
    'modifiedBy'?: number | null;
    /**
     * 
     * @type {EmployeeTypes}
     * @memberof EmployeeModel
     */
    'type'?: EmployeeTypes | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'code'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EmployeeModel
     */
    'salaryType'?: number;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'socialSecurityNumber'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EmployeeModel
     */
    'employerSocialSecurityRate'?: number;
    /**
     * 
     * @type {number}
     * @memberof EmployeeModel
     */
    'employeeSocialSecurityRate'?: number;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'dob'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'address'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'contactName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'contactNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'contactRelationship'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'office'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EmployeeModel
     */
    'socialSecurityStatus'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof EmployeeModel
     */
    'methodPayment'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'secondaryEmail'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof EmployeeModel
     */
    'isDelete'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof EmployeeModel
     */
    'socialSecurityValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof EmployeeModel
     */
    'withholdingTax'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EmployeeModel
     */
    'isHeadOffice'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'companyBranch'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EmployeeModel
     */
    'maritalStatus'?: number;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'currentAddress'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EmployeeModel
     */
    'departmentId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'firstNameForeign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'lastNameForeign'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof EmployeeModel
     */
    'isSocialSecurityRegistered'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'bankBranchCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EmployeeModel
     */
    'idCard'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof EmployeeModel
     */
    'householdRegistration'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'nickname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'nicknameForeign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'lineId'?: string | null;
    /**
     * 
     * @type {ConditionsOfWithholdingTax}
     * @memberof EmployeeModel
     */
    'conditionsWithholdingTax'?: ConditionsOfWithholdingTax | null;
    /**
     * 
     * @type {PaidPeriod}
     * @memberof EmployeeModel
     */
    'paidPeriod'?: PaidPeriod;
    /**
     * 
     * @type {Bank}
     * @memberof EmployeeModel
     */
    'bank'?: Bank | null;
    /**
     * 
     * @type {Company}
     * @memberof EmployeeModel
     */
    'company'?: Company | null;
    /**
     * 
     * @type {Gallery}
     * @memberof EmployeeModel
     */
    'gallery'?: Gallery | null;
    /**
     * 
     * @type {Gallery}
     * @memberof EmployeeModel
     */
    'galleryIdCard'?: Gallery | null;
    /**
     * 
     * @type {Gallery}
     * @memberof EmployeeModel
     */
    'galleryHouseholdRegistration'?: Gallery | null;
    /**
     * 
     * @type {Array<PayrollDetail>}
     * @memberof EmployeeModel
     */
    'payrollDetail'?: Array<PayrollDetail> | null;
    /**
     * 
     * @type {Department}
     * @memberof EmployeeModel
     */
    'department'?: Department | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeeModel
     */
    'reason'?: string | null;
}
/**
 * 
 * @export
 * @interface EmployeeModelAllOf
 */
export interface EmployeeModelAllOf {
    /**
     * 
     * @type {string}
     * @memberof EmployeeModelAllOf
     */
    'reason'?: string | null;
}
/**
 * 1 = EmpWithOutOT 3 = EmpWithOT 5 = EmpByDayHour 7 = Owner
 * @export
 * @enum {string}
 */

export const EmployeeTypes = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7
} as const;

export type EmployeeTypes = typeof EmployeeTypes[keyof typeof EmployeeTypes];


/**
 * 1 = PND3 3 = PND53 5 = PND1K 7 = PND1KSpecial 9 = PND2 11 = PND2K 13 = PND3K 15 = PND1
 * @export
 * @enum {string}
 */

export const Entity = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7,
    NUMBER_9: 9,
    NUMBER_11: 11,
    NUMBER_13: 13,
    NUMBER_15: 15
} as const;

export type Entity = typeof Entity[keyof typeof Entity];


/**
 * 
 * @export
 * @interface ExpenseCategory
 */
export interface ExpenseCategory {
    /**
     * 
     * @type {number}
     * @memberof ExpenseCategory
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpenseCategory
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ExpenseCategory
     */
    'nameForeign'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseCategory
     */
    'isShare'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseCategory
     */
    'isDelete'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseCategory
     */
    'isGLSystem'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ExpenseCategory
     */
    'systemCode'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseCategory
     */
    'resetTransactionId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseCategory
     */
    'taxLife'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseCategory
     */
    'chartOfAccountId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseCategory
     */
    'chartOfAccountIdCredit'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseCategory
     */
    'depreciationChartOfAccountId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseCategory
     */
    'accumulatedDepreciationChartOfAccountId'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseCategory
     */
    'depreciableAsset'?: boolean | null;
    /**
     * 
     * @type {Array<ExpenseList>}
     * @memberof ExpenseCategory
     */
    'expenseList'?: Array<ExpenseList> | null;
    /**
     * 
     * @type {Array<CompanyExpenseCategory>}
     * @memberof ExpenseCategory
     */
    'companyExpenseCategory'?: Array<CompanyExpenseCategory> | null;
}
/**
 * 
 * @export
 * @interface ExpenseList
 */
export interface ExpenseList {
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'vendorCompanyId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'companyId'?: number;
    /**
     * 
     * @type {ExpenseStatus}
     * @memberof ExpenseList
     */
    'status'?: ExpenseStatus;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'receiptImage'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'value'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'expenseCategoryId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'documentSerial'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'documentId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'publishedOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'expenseDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'documentDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'createdOn'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'createdBy'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'modifiedOn'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseList
     */
    'published'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseList
     */
    'approved'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'approvedBy'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'remarks'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseList
     */
    'isTax'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseList
     */
    'isDelete'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseList
     */
    'taxRefundable'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'galleryId'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseList
     */
    'reconciled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'nullableContactId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'bankAccountNumber'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseList
     */
    'isVatInclusive'?: boolean;
    /**
     * 
     * @type {PaymentMethod}
     * @memberof ExpenseList
     */
    'methodPayment'?: PaymentMethod | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'vendorName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'addressLocal'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'addressLocalLine2'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'addressLocalLine3'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'companyTaxId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'branch'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'vatRate'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'tax'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'valueIncludeVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'vatAmount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'documentSerialNoPrefix'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'withholding'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'charge'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'datePayment'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'checkNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'checkBankId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'checkDatePaid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'transferBankId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'collected': number;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'outstanding': number;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'paymentWithHeld': number;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'resetTransactionId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'bankAccountId'?: number | null;
    /**
     * 
     * @type {RuleCompileStatus}
     * @memberof ExpenseList
     */
    'ruleCompileStatus'?: RuleCompileStatus;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'remainingCollected'?: number | null;
    /**
     * 
     * @type {RemainingCollectedType}
     * @memberof ExpenseList
     */
    'remainingCollectedType'?: RemainingCollectedType | null;
    /**
     * 
     * @type {Company}
     * @memberof ExpenseList
     */
    'company'?: Company | null;
    /**
     * 
     * @type {Company}
     * @memberof ExpenseList
     */
    'vendorCompany'?: Company | null;
    /**
     * 
     * @type {ExpenseCategory}
     * @memberof ExpenseList
     */
    'expenseCategory'?: ExpenseCategory | null;
    /**
     * 
     * @type {Gallery}
     * @memberof ExpenseList
     */
    'gallery'?: Gallery | null;
    /**
     * 
     * @type {Contact}
     * @memberof ExpenseList
     */
    'contact'?: Contact | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'runningNumberType'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'runningModifiedOn'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseList
     */
    'isForeignCurrency'?: boolean;
    /**
     * 
     * @type {Currency}
     * @memberof ExpenseList
     */
    'foreignCurrency'?: Currency | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'exchangeRate'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'foreignValue'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'exemptAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'vatableAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'totalAfterDiscount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'dueDate'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'subTotal'?: number;
    /**
     * 
     * @type {Array<PayrollDetail>}
     * @memberof ExpenseList
     */
    'payrollDetail'?: Array<PayrollDetail> | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'batchTaxFilingId'?: number | null;
    /**
     * 
     * @type {BatchTaxFiling}
     * @memberof ExpenseList
     */
    'batchTaxFiling'?: BatchTaxFiling | null;
    /**
     * 
     * @type {SupplierInvoiceStatus}
     * @memberof ExpenseList
     */
    'supplierInvoiceStatus'?: SupplierInvoiceStatus | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'saleAndPurchaseChannel'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'pettyCashName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'pettyCashId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'chequeId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'creditCardId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'otherChannelId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'chequeCashingDate'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseList
     */
    'autoCreateWithholdingTax'?: boolean | null;
    /**
     * 
     * @type {IncomeType}
     * @memberof ExpenseList
     */
    'withholdingTaxIncomeType'?: IncomeType | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'withholdingTaxIncomeDescription'?: string | null;
    /**
     * 
     * @type {Entity}
     * @memberof ExpenseList
     */
    'withholdingTaxEntity'?: Entity | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'exchangeRatio'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseList
     */
    'isManualRate'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'exchangeRateDate'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'companyCurrencyId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'foreignInlineVatValue'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'foreignInlineDiscountValue'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'foreignVatAmount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'foreignDeductionAmount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'projectId'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseList
     */
    'isManualVat'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'externalDocumentId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'batchId'?: string | null;
    /**
     * 
     * @type {Array<IDocumentReference>}
     * @memberof ExpenseList
     */
    'documentReferences'?: Array<IDocumentReference> | null;
    /**
     * 
     * @type {Array<IDocumentReference>}
     * @memberof ExpenseList
     */
    'referencedToMe'?: Array<IDocumentReference> | null;
    /**
     * 
     * @type {Array<IDocumentReference>}
     * @memberof ExpenseList
     */
    'referencedByMe'?: Array<IDocumentReference> | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'statusInt'?: number;
    /**
     * 
     * @type {PartialPaymentMethod}
     * @memberof ExpenseList
     */
    'partialPaymentMethod'?: PartialPaymentMethod | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'refDocumentStatus'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'refDocumentStatusString'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseList
     */
    'isReCalculate'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'inlineVatValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'inlineDiscountValue'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseList
     */
    'isMigrate'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'vatValue'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'deductionAmount'?: number | null;
    /**
     * 
     * @type {DeductionType}
     * @memberof ExpenseList
     */
    'paymentDeductionType'?: DeductionType | null;
    /**
     * 
     * @type {DeductionType}
     * @memberof ExpenseList
     */
    'documentDeductionType'?: DeductionType | null;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseList
     */
    'isInlineDiscount'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseList
     */
    'isInlineVat'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'contactId'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'valueExcludeVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpenseList
     */
    'roundingAdjustment'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'internalNotes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'projectName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseList
     */
    'projectNameAndProjectDeatil'?: string | null;
}
/**
 * 
 * @export
 * @interface ExpenseListAllOf
 */
export interface ExpenseListAllOf {
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'vendorCompanyId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'companyId'?: number;
    /**
     * 
     * @type {ExpenseStatus}
     * @memberof ExpenseListAllOf
     */
    'status'?: ExpenseStatus;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'receiptImage'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'value'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'expenseCategoryId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'documentSerial'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'documentId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'publishedOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'expenseDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'documentDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'createdOn'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'createdBy'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'modifiedOn'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseListAllOf
     */
    'published'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseListAllOf
     */
    'approved'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'approvedBy'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'remarks'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseListAllOf
     */
    'isTax'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseListAllOf
     */
    'isDelete'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseListAllOf
     */
    'taxRefundable'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'galleryId'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseListAllOf
     */
    'reconciled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'nullableContactId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'bankAccountNumber'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseListAllOf
     */
    'isVatInclusive'?: boolean;
    /**
     * 
     * @type {PaymentMethod}
     * @memberof ExpenseListAllOf
     */
    'methodPayment'?: PaymentMethod | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'vendorName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'addressLocal'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'addressLocalLine2'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'addressLocalLine3'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'companyTaxId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'branch'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'vatRate'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'tax'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'valueIncludeVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'vatAmount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'documentSerialNoPrefix'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'withholding'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'charge'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'datePayment'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'checkNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'checkBankId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'checkDatePaid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'transferBankId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'collected': number;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'outstanding': number;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'paymentWithHeld': number;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'resetTransactionId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'bankAccountId'?: number | null;
    /**
     * 
     * @type {RuleCompileStatus}
     * @memberof ExpenseListAllOf
     */
    'ruleCompileStatus'?: RuleCompileStatus;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'remainingCollected'?: number | null;
    /**
     * 
     * @type {RemainingCollectedType}
     * @memberof ExpenseListAllOf
     */
    'remainingCollectedType'?: RemainingCollectedType | null;
    /**
     * 
     * @type {Company}
     * @memberof ExpenseListAllOf
     */
    'company'?: Company | null;
    /**
     * 
     * @type {Company}
     * @memberof ExpenseListAllOf
     */
    'vendorCompany'?: Company | null;
    /**
     * 
     * @type {ExpenseCategory}
     * @memberof ExpenseListAllOf
     */
    'expenseCategory'?: ExpenseCategory | null;
    /**
     * 
     * @type {Gallery}
     * @memberof ExpenseListAllOf
     */
    'gallery'?: Gallery | null;
    /**
     * 
     * @type {Contact}
     * @memberof ExpenseListAllOf
     */
    'contact'?: Contact | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'runningNumberType'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'runningModifiedOn'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseListAllOf
     */
    'isForeignCurrency'?: boolean;
    /**
     * 
     * @type {Currency}
     * @memberof ExpenseListAllOf
     */
    'foreignCurrency'?: Currency | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'exchangeRate'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'foreignValue'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'exemptAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'vatableAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'totalAfterDiscount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'dueDate'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'subTotal'?: number;
    /**
     * 
     * @type {Array<PayrollDetail>}
     * @memberof ExpenseListAllOf
     */
    'payrollDetail'?: Array<PayrollDetail> | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'batchTaxFilingId'?: number | null;
    /**
     * 
     * @type {BatchTaxFiling}
     * @memberof ExpenseListAllOf
     */
    'batchTaxFiling'?: BatchTaxFiling | null;
    /**
     * 
     * @type {SupplierInvoiceStatus}
     * @memberof ExpenseListAllOf
     */
    'supplierInvoiceStatus'?: SupplierInvoiceStatus | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'saleAndPurchaseChannel'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'pettyCashName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'pettyCashId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'chequeId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'creditCardId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'otherChannelId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'chequeCashingDate'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseListAllOf
     */
    'autoCreateWithholdingTax'?: boolean | null;
    /**
     * 
     * @type {IncomeType}
     * @memberof ExpenseListAllOf
     */
    'withholdingTaxIncomeType'?: IncomeType | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'withholdingTaxIncomeDescription'?: string | null;
    /**
     * 
     * @type {Entity}
     * @memberof ExpenseListAllOf
     */
    'withholdingTaxEntity'?: Entity | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'exchangeRatio'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseListAllOf
     */
    'isManualRate'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'exchangeRateDate'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'companyCurrencyId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'foreignInlineVatValue'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'foreignInlineDiscountValue'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'foreignVatAmount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'foreignDeductionAmount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'projectId'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseListAllOf
     */
    'isManualVat'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'externalDocumentId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'batchId'?: string | null;
    /**
     * 
     * @type {Array<IDocumentReference>}
     * @memberof ExpenseListAllOf
     */
    'documentReferences'?: Array<IDocumentReference> | null;
    /**
     * 
     * @type {Array<IDocumentReference>}
     * @memberof ExpenseListAllOf
     */
    'referencedToMe'?: Array<IDocumentReference> | null;
    /**
     * 
     * @type {Array<IDocumentReference>}
     * @memberof ExpenseListAllOf
     */
    'referencedByMe'?: Array<IDocumentReference> | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'statusInt'?: number;
    /**
     * 
     * @type {PartialPaymentMethod}
     * @memberof ExpenseListAllOf
     */
    'partialPaymentMethod'?: PartialPaymentMethod | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'refDocumentStatus'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'refDocumentStatusString'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseListAllOf
     */
    'isReCalculate'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'inlineVatValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'inlineDiscountValue'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseListAllOf
     */
    'isMigrate'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'vatValue'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'deductionAmount'?: number | null;
    /**
     * 
     * @type {DeductionType}
     * @memberof ExpenseListAllOf
     */
    'paymentDeductionType'?: DeductionType | null;
    /**
     * 
     * @type {DeductionType}
     * @memberof ExpenseListAllOf
     */
    'documentDeductionType'?: DeductionType | null;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseListAllOf
     */
    'isInlineDiscount'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ExpenseListAllOf
     */
    'isInlineVat'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'contactId'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'valueExcludeVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpenseListAllOf
     */
    'roundingAdjustment'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'internalNotes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'projectName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExpenseListAllOf
     */
    'projectNameAndProjectDeatil'?: string | null;
}
/**
 * 1 = Awaiting 3 = Approved 4 = PendingPayment 5 = Paid 6 = PaidByPaymentSlip 7 = Void 9 = ApprovedAndProcessed 11 = Received 23 = ReceivedByPaymentSlip
 * @export
 * @enum {string}
 */

export const ExpenseStatus = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_6: 6,
    NUMBER_7: 7,
    NUMBER_9: 9,
    NUMBER_11: 11,
    NUMBER_23: 23
} as const;

export type ExpenseStatus = typeof ExpenseStatus[keyof typeof ExpenseStatus];


/**
 * 
 * @export
 * @interface FilterOptions
 */
export interface FilterOptions {
    /**
     * 
     * @type {string}
     * @memberof FilterOptions
     */
    'columnName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FilterOptions
     */
    'columnValue'?: string | null;
    /**
     * 
     * @type {PredicateOperator}
     * @memberof FilterOptions
     */
    'columnPredicateOperator'?: PredicateOperator;
}
/**
 * 1 = Debit 3 = Credit
 * @export
 * @enum {string}
 */

export const FinancialTransactionType = {
    NUMBER_1: 1,
    NUMBER_3: 3
} as const;

export type FinancialTransactionType = typeof FinancialTransactionType[keyof typeof FinancialTransactionType];


/**
 * 
 * @export
 * @interface FiscalYear
 */
export interface FiscalYear {
    /**
     * 
     * @type {number}
     * @memberof FiscalYear
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof FiscalYear
     */
    'companyId'?: number;
    /**
     * 
     * @type {string}
     * @memberof FiscalYear
     */
    'beginPeriod'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiscalYear
     */
    'endPeriod'?: string;
    /**
     * 
     * @type {FiscalYearStatus}
     * @memberof FiscalYear
     */
    'status'?: FiscalYearStatus;
    /**
     * 
     * @type {string}
     * @memberof FiscalYear
     */
    'closedOn'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FiscalYear
     */
    'closedBy'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FiscalYear
     */
    'createdOn'?: string;
    /**
     * 
     * @type {Company}
     * @memberof FiscalYear
     */
    'company'?: Company | null;
}
/**
 * 1 = Current 3 = Opening 5 = Closed
 * @export
 * @enum {string}
 */

export const FiscalYearStatus = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5
} as const;

export type FiscalYearStatus = typeof FiscalYearStatus[keyof typeof FiscalYearStatus];


/**
 * 
 * @export
 * @interface Gallery
 */
export interface Gallery {
    /**
     * 
     * @type {number}
     * @memberof Gallery
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Gallery
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Gallery
     */
    'description'?: string | null;
    /**
     * 
     * @type {Array<ProductList>}
     * @memberof Gallery
     */
    'productList'?: Array<ProductList> | null;
    /**
     * 
     * @type {Array<Media>}
     * @memberof Gallery
     */
    'media'?: Array<Media> | null;
    /**
     * 
     * @type {Array<JournalEntry>}
     * @memberof Gallery
     */
    'journalEntry'?: Array<JournalEntry> | null;
    /**
     * 
     * @type {Array<ReceivableInvoice>}
     * @memberof Gallery
     */
    'receivableInvoice'?: Array<ReceivableInvoice> | null;
    /**
     * 
     * @type {Array<SupplierInvoice>}
     * @memberof Gallery
     */
    'supplierInvoice'?: Array<SupplierInvoice> | null;
}
/**
 * 1 = Mr 3 = Mrs 5 = Ms
 * @export
 * @enum {string}
 */

export const GenderPrefix = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5
} as const;

export type GenderPrefix = typeof GenderPrefix[keyof typeof GenderPrefix];


/**
 * 
 * @export
 * @interface IBookOfAccount
 */
export interface IBookOfAccount {
    /**
     * 
     * @type {number}
     * @memberof IBookOfAccount
     */
    'journalEntryId'?: number;
    /**
     * 
     * @type {number}
     * @memberof IBookOfAccount
     */
    'companyId'?: number;
    /**
     * 
     * @type {FinancialTransactionType}
     * @memberof IBookOfAccount
     */
    'debitCredit'?: FinancialTransactionType;
    /**
     * 
     * @type {BookOfAccountStatus}
     * @memberof IBookOfAccount
     */
    'bookOfAccountStatus'?: BookOfAccountStatus;
    /**
     * 
     * @type {number}
     * @memberof IBookOfAccount
     */
    'chartOfAccountId'?: number;
    /**
     * 
     * @type {string}
     * @memberof IBookOfAccount
     */
    'postedDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IBookOfAccount
     */
    'createdOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof IBookOfAccount
     */
    'modifiedOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof IBookOfAccount
     */
    'approvedOn'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof IBookOfAccount
     */
    'value'?: number;
    /**
     * 
     * @type {number}
     * @memberof IBookOfAccount
     */
    'balance'?: number;
    /**
     * 
     * @type {number}
     * @memberof IBookOfAccount
     */
    'excludeVoidBalance'?: number;
    /**
     * 
     * @type {number}
     * @memberof IBookOfAccount
     */
    'rowNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof IBookOfAccount
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IBookOfAccount
     */
    'descriptionForeign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IBookOfAccount
     */
    'chartOfAccountName'?: string | null;
    /**
     * 
     * @type {IJournalEntryBase}
     * @memberof IBookOfAccount
     */
    'journalEntry'?: IJournalEntryBase | null;
    /**
     * 
     * @type {IChartOfAccount}
     * @memberof IBookOfAccount
     */
    'chartOfAccount'?: IChartOfAccount | null;
}
/**
 * 
 * @export
 * @interface IChartOfAccount
 */
export interface IChartOfAccount {
    /**
     * 
     * @type {number}
     * @memberof IChartOfAccount
     */
    'id'?: number;
    /**
     * 
     * @type {ChartOfAccountCategory}
     * @memberof IChartOfAccount
     */
    'category'?: ChartOfAccountCategory;
    /**
     * 
     * @type {string}
     * @memberof IChartOfAccount
     */
    'code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IChartOfAccount
     */
    'nameLocal'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IChartOfAccount
     */
    'nameForeign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IChartOfAccount
     */
    'descriptionLocal'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IChartOfAccount
     */
    'descriptionForeign'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof IChartOfAccount
     */
    'parentId'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof IChartOfAccount
     */
    'isFolder'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IChartOfAccount
     */
    'isBank'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IChartOfAccount
     */
    'isReceivable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IChartOfAccount
     */
    'isDelete'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IChartOfAccount
     */
    'isLock'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IChartOfAccount
     */
    'createdon'?: string;
    /**
     * 
     * @type {string}
     * @memberof IChartOfAccount
     */
    'modifiedon'?: string;
    /**
     * 
     * @type {number}
     * @memberof IChartOfAccount
     */
    'modifiedby'?: number;
    /**
     * 
     * @type {number}
     * @memberof IChartOfAccount
     */
    'value'?: number;
    /**
     * 
     * @type {number}
     * @memberof IChartOfAccount
     */
    'left'?: number;
    /**
     * 
     * @type {number}
     * @memberof IChartOfAccount
     */
    'right'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof IChartOfAccount
     */
    'isDefault'?: boolean;
}
/**
 * 
 * @export
 * @interface IDocumentReference
 */
export interface IDocumentReference {
    /**
     * 
     * @type {number}
     * @memberof IDocumentReference
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof IDocumentReference
     */
    'companyId'?: number;
    /**
     * 
     * @type {number}
     * @memberof IDocumentReference
     */
    'referenceId'?: number;
    /**
     * 
     * @type {DocumentTypes}
     * @memberof IDocumentReference
     */
    'referenceDocumentType'?: DocumentTypes;
    /**
     * 
     * @type {string}
     * @memberof IDocumentReference
     */
    'referenceDocumentSerial'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof IDocumentReference
     */
    'documentId'?: number;
    /**
     * 
     * @type {DocumentTypes}
     * @memberof IDocumentReference
     */
    'documentType'?: DocumentTypes;
    /**
     * 
     * @type {string}
     * @memberof IDocumentReference
     */
    'documentSerial'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof IDocumentReference
     */
    'isDelete'?: boolean;
    /**
     * 
     * @type {DocumentReferenceTypes}
     * @memberof IDocumentReference
     */
    'type'?: DocumentReferenceTypes;
    /**
     * 
     * @type {number}
     * @memberof IDocumentReference
     */
    'documentStatus'?: number;
    /**
     * 
     * @type {string}
     * @memberof IDocumentReference
     */
    'documentStatusString'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IDocumentReference
     */
    'documentDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof IDocumentReference
     */
    'documentAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof IDocumentReference
     */
    'documentAmountWithVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof IDocumentReference
     */
    'refDocumentStatus'?: number;
    /**
     * 
     * @type {string}
     * @memberof IDocumentReference
     */
    'refDocumentStatusString'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IDocumentReference
     */
    'refDocumentDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof IDocumentReference
     */
    'refDocumentAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof IDocumentReference
     */
    'refDocumentAmountWithVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof IDocumentReference
     */
    'partialPaymentTotalAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof IDocumentReference
     */
    'partialPaymentTotalPercent'?: number;
    /**
     * 
     * @type {string}
     * @memberof IDocumentReference
     */
    'refCreatedOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof IDocumentReference
     */
    'refModifiedOn'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IDocumentReference
     */
    'refIsMigrate'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IDocumentReference
     */
    'isCompileRule'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof IDocumentReference
     */
    'documentCollected'?: number;
}
/**
 * 
 * @export
 * @interface IJournalEntryBase
 */
export interface IJournalEntryBase {
    /**
     * 
     * @type {number}
     * @memberof IJournalEntryBase
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof IJournalEntryBase
     */
    'companyId'?: number;
    /**
     * 
     * @type {string}
     * @memberof IJournalEntryBase
     */
    'documentSerial'?: string | null;
    /**
     * 
     * @type {DocumentTypes}
     * @memberof IJournalEntryBase
     */
    'documentType'?: DocumentTypes;
    /**
     * 
     * @type {JournalEntryStatus}
     * @memberof IJournalEntryBase
     */
    'status'?: JournalEntryStatus;
    /**
     * 
     * @type {string}
     * @memberof IJournalEntryBase
     */
    'documentDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof IJournalEntryBase
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IJournalEntryBase
     */
    'descriptionForeign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IJournalEntryBase
     */
    'voidDescription'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IJournalEntryBase
     */
    'createdOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof IJournalEntryBase
     */
    'modifiedOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof IJournalEntryBase
     */
    'voidedOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IJournalEntryBase
     */
    'approvedOn'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof IJournalEntryBase
     */
    'transactionNo'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof IJournalEntryBase
     */
    'note'?: string | null;
    /**
     * 
     * @type {JournalEntryTemplateType}
     * @memberof IJournalEntryBase
     */
    'templateType'?: JournalEntryTemplateType;
    /**
     * 
     * @type {string}
     * @memberof IJournalEntryBase
     */
    'contactName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof IJournalEntryBase
     */
    'documentSerialNoPrefix'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof IJournalEntryBase
     */
    'createdBy'?: number;
    /**
     * 
     * @type {number}
     * @memberof IJournalEntryBase
     */
    'modifiedBy'?: number;
    /**
     * 
     * @type {number}
     * @memberof IJournalEntryBase
     */
    'approvedBy'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof IJournalEntryBase
     */
    'voidedBy'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof IJournalEntryBase
     */
    'galleryId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof IJournalEntryBase
     */
    'contactId'?: number | null;
    /**
     * 
     * @type {RunningNumberType}
     * @memberof IJournalEntryBase
     */
    'runningNumberType'?: RunningNumberType | null;
    /**
     * 
     * @type {number}
     * @memberof IJournalEntryBase
     */
    'fiscalYearId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof IJournalEntryBase
     */
    'reference'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof IJournalEntryBase
     */
    'referenceId'?: number | null;
    /**
     * 
     * @type {DocumentTypes}
     * @memberof IJournalEntryBase
     */
    'referenceDocumentType'?: DocumentTypes | null;
    /**
     * 
     * @type {boolean}
     * @memberof IJournalEntryBase
     */
    'isSystemDocument'?: boolean;
    /**
     * 
     * @type {RuleCompileStatus}
     * @memberof IJournalEntryBase
     */
    'ruleCompileStatus'?: RuleCompileStatus;
}
/**
 * 
 * @export
 * @interface IProductResult
 */
export interface IProductResult {
    /**
     * 
     * @type {number}
     * @memberof IProductResult
     */
    'id'?: number;
    /**
     * 
     * @type {ProductTypes}
     * @memberof IProductResult
     */
    'type'?: ProductTypes;
    /**
     * 
     * @type {string}
     * @memberof IProductResult
     */
    'code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IProductResult
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IProductResult
     */
    'barcode'?: string | null;
    /**
     * 
     * @type {VatTypes}
     * @memberof IProductResult
     */
    'buyVatType'?: VatTypes;
    /**
     * 
     * @type {number}
     * @memberof IProductResult
     */
    'buyPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof IProductResult
     */
    'buyPriceWithVat'?: number;
    /**
     * 
     * @type {string}
     * @memberof IProductResult
     */
    'buyDescription'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof IProductResult
     */
    'buyChartOfAccountId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof IProductResult
     */
    'buyChartOfAccountCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IProductResult
     */
    'buyChartOfAccountNameLocal'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IProductResult
     */
    'buyChartOfAccountNameForeign'?: string | null;
    /**
     * 
     * @type {VatTypes}
     * @memberof IProductResult
     */
    'sellVatType'?: VatTypes;
    /**
     * 
     * @type {number}
     * @memberof IProductResult
     */
    'sellPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof IProductResult
     */
    'sellPriceWithVat'?: number;
    /**
     * 
     * @type {string}
     * @memberof IProductResult
     */
    'sellDescription'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof IProductResult
     */
    'sellChartOfAccountId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof IProductResult
     */
    'sellChartOfAccountCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IProductResult
     */
    'sellChartOfAccountNameLocal'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IProductResult
     */
    'sellChartOfAccountNameForeign'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof IProductResult
     */
    'categoryId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof IProductResult
     */
    'categoryName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof IProductResult
     */
    'unitId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof IProductResult
     */
    'unitName'?: string | null;
    /**
     * 
     * @type {ProductNonInventoryType}
     * @memberof IProductResult
     */
    'productNonInventoryType'?: ProductNonInventoryType | null;
    /**
     * 
     * @type {string}
     * @memberof IProductResult
     */
    'broughtForwardOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IProductResult
     */
    'inventoryPublishedOn'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof IProductResult
     */
    'inventoryQuantity'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof IProductResult
     */
    'inventoryPrice'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof IProductResult
     */
    'inventoryTotal'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof IProductResult
     */
    'inventoryRemark'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof IProductResult
     */
    'averageBuyPrice'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof IProductResult
     */
    'averageSellPrice'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof IProductResult
     */
    'remainingStock'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof IProductResult
     */
    'totalValueInHand'?: number | null;
    /**
     * 
     * @type {Array<IStockCard>}
     * @memberof IProductResult
     */
    'stockCard'?: Array<IStockCard> | null;
}
/**
 * 
 * @export
 * @interface ISimpleListResultOfIProductResult
 */
export interface ISimpleListResultOfIProductResult {
    /**
     * 
     * @type {Array<IProductResult>}
     * @memberof ISimpleListResultOfIProductResult
     */
    'list'?: Array<IProductResult> | null;
}
/**
 * 
 * @export
 * @interface IStockCard
 */
export interface IStockCard {
    /**
     * 
     * @type {ObjectId}
     * @memberof IStockCard
     */
    'id'?: ObjectId;
    /**
     * 
     * @type {number}
     * @memberof IStockCard
     */
    'productId'?: number;
    /**
     * 
     * @type {string}
     * @memberof IStockCard
     */
    'productName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IStockCard
     */
    'productCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof IStockCard
     */
    'inventoryId'?: number;
    /**
     * 
     * @type {InventoryType}
     * @memberof IStockCard
     */
    'inventoryType'?: InventoryType;
    /**
     * 
     * @type {string}
     * @memberof IStockCard
     */
    'date'?: string;
    /**
     * 
     * @type {number}
     * @memberof IStockCard
     */
    'quantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof IStockCard
     */
    'unitId'?: number;
    /**
     * 
     * @type {number}
     * @memberof IStockCard
     */
    'unitPrice'?: number;
    /**
     * 
     * @type {string}
     * @memberof IStockCard
     */
    'unitName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof IStockCard
     */
    'total'?: number;
    /**
     * 
     * @type {number}
     * @memberof IStockCard
     */
    'remaining'?: number;
    /**
     * 
     * @type {DocumentTypes}
     * @memberof IStockCard
     */
    'documentType'?: DocumentTypes;
    /**
     * 
     * @type {string}
     * @memberof IStockCard
     */
    'documentSerial'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof IStockCard
     */
    'allowDelete'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IStockCard
     */
    'remarks'?: string | null;
    /**
     * 
     * @type {AdjustInventoryReason}
     * @memberof IStockCard
     */
    'reason'?: AdjustInventoryReason;
    /**
     * 
     * @type {string}
     * @memberof IStockCard
     */
    'contactName'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof IStockCard
     */
    'isOverSold'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof IStockCard
     */
    'rowIndex'?: number;
    /**
     * 
     * @type {string}
     * @memberof IStockCard
     */
    'reasonDescription'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof IStockCard
     */
    'averagePricePerUnit'?: number;
    /**
     * 
     * @type {number}
     * @memberof IStockCard
     */
    'remainingAmount'?: number;
    /**
     * 
     * @type {Array<IStockCard>}
     * @memberof IStockCard
     */
    'transactions'?: Array<IStockCard> | null;
}
/**
 * 
 * @export
 * @interface ImageResult
 */
export interface ImageResult {
    /**
     * 
     * @type {number}
     * @memberof ImageResult
     */
    'companyId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ImageResult
     */
    'fileName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ImageResult
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ImageResult
     */
    'previewURL'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ImageResult
     */
    'thumbURL'?: string | null;
}
/**
 * 1 = Salary 3 = Commission 5 = Licensing 7 = Interest 9 = NetProfit30 11 = NetProfit25 13 = NetProfit20 15 = NetProfitOther 17 = TaxExemption 19 = DividenFromShareOfProfit 21 = PortionOfNetProfit 23 = RecognitionOfProfit 25 = TaxOther 27 = RevenueDepartmentTax 29 = Others
 * @export
 * @enum {string}
 */

export const IncomeType = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7,
    NUMBER_9: 9,
    NUMBER_11: 11,
    NUMBER_13: 13,
    NUMBER_15: 15,
    NUMBER_17: 17,
    NUMBER_19: 19,
    NUMBER_21: 21,
    NUMBER_23: 23,
    NUMBER_25: 25,
    NUMBER_27: 27,
    NUMBER_29: 29
} as const;

export type IncomeType = typeof IncomeType[keyof typeof IncomeType];


/**
 * 
 * @export
 * @interface InlineDocument
 */
export interface InlineDocument {
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'recordId'?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'contactCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'contactName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'contactAddress'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'contactTaxId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'contactBranch'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'contactPerson'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'contactEmail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'contactNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'contactZipCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'contactGroup'?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'publishedOn'?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'creditType'?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'creditDays'?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'dueDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'salesName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'projectName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'reference'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof InlineDocument
     */
    'isVatInclusive'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineDocument
     */
    'useReceiptDeduction'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'subTotal'?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'discountPercentage'?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'discountAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'totalAfterDiscount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof InlineDocument
     */
    'isVat'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'vatAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'grandTotal'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof InlineDocument
     */
    'documentShowWithholdingTax'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'documentWithholdingTaxPercentage'?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'documentWithholdingTaxAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'documentDeductionType'?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'documentDeductionAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'remarks'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'internalNotes'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof InlineDocument
     */
    'showSignatureOrStamp'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'documentStructureType'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'externalId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'saleAndPurchaseChannel'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'rowIndex'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'discountType'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof InlineDocument
     */
    'useInlineDiscount'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineDocument
     */
    'useInlineVat'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'exemptAmount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'vatableAmount'?: number | null;
    /**
     * 
     * @type {Array<InlineProductItem>}
     * @memberof InlineDocument
     */
    'items'?: Array<InlineProductItem> | null;
    /**
     * 
     * @type {Array<UpgradeDocument>}
     * @memberof InlineDocument
     */
    'documentReference'?: Array<UpgradeDocument> | null;
}
/**
 * 
 * @export
 * @interface InlineDocumentAllOf
 */
export interface InlineDocumentAllOf {
    /**
     * 
     * @type {number}
     * @memberof InlineDocumentAllOf
     */
    'discountType'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof InlineDocumentAllOf
     */
    'useInlineDiscount'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineDocumentAllOf
     */
    'useInlineVat'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineDocumentAllOf
     */
    'exemptAmount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof InlineDocumentAllOf
     */
    'vatableAmount'?: number | null;
    /**
     * 
     * @type {Array<InlineProductItem>}
     * @memberof InlineDocumentAllOf
     */
    'items'?: Array<InlineProductItem> | null;
    /**
     * 
     * @type {Array<UpgradeDocument>}
     * @memberof InlineDocumentAllOf
     */
    'documentReference'?: Array<UpgradeDocument> | null;
}
/**
 * 
 * @export
 * @interface InlineProductItem
 */
export interface InlineProductItem {
    /**
     * 
     * @type {number}
     * @memberof InlineProductItem
     */
    'type'?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineProductItem
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineProductItem
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof InlineProductItem
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineProductItem
     */
    'unitName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof InlineProductItem
     */
    'pricePerUnit'?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineProductItem
     */
    'total'?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineProductItem
     */
    'sellChartOfAccountCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineProductItem
     */
    'buyChartOfAccountCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof InlineProductItem
     */
    'discountAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineProductItem
     */
    'vatRate'?: number;
}
/**
 * 3 = Initial 5 = BroughtForward 7 = In 11 = TransferIn 17 = Out 21 = TransferOut 25 = CreditNote 27 = DebitNote 29 = InternalUse 31 = Hold 35 = AdjustIn 39 = AdjustOut
 * @export
 * @enum {string}
 */

export const InventoryType = {
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7,
    NUMBER_11: 11,
    NUMBER_17: 17,
    NUMBER_21: 21,
    NUMBER_25: 25,
    NUMBER_27: 27,
    NUMBER_29: 29,
    NUMBER_31: 31,
    NUMBER_35: 35,
    NUMBER_39: 39
} as const;

export type InventoryType = typeof InventoryType[keyof typeof InventoryType];


/**
 * 
 * @export
 * @interface JournalEntry
 */
export interface JournalEntry {
    /**
     * 
     * @type {number}
     * @memberof JournalEntry
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof JournalEntry
     */
    'companyId'?: number;
    /**
     * 
     * @type {string}
     * @memberof JournalEntry
     */
    'documentSerial'?: string | null;
    /**
     * 
     * @type {DocumentTypes}
     * @memberof JournalEntry
     */
    'documentType': DocumentTypes;
    /**
     * 
     * @type {JournalEntryStatus}
     * @memberof JournalEntry
     */
    'status': JournalEntryStatus;
    /**
     * 
     * @type {string}
     * @memberof JournalEntry
     */
    'documentDate': string;
    /**
     * 
     * @type {string}
     * @memberof JournalEntry
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof JournalEntry
     */
    'descriptionForeign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof JournalEntry
     */
    'voidDescription'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof JournalEntry
     */
    'voidedOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof JournalEntry
     */
    'approvedOn'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof JournalEntry
     */
    'transactionNo'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof JournalEntry
     */
    'note'?: string | null;
    /**
     * 
     * @type {JournalEntryTemplateType}
     * @memberof JournalEntry
     */
    'templateType'?: JournalEntryTemplateType;
    /**
     * 
     * @type {string}
     * @memberof JournalEntry
     */
    'contactName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof JournalEntry
     */
    'documentSerialNoPrefix'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof JournalEntry
     */
    'createdBy'?: number;
    /**
     * 
     * @type {number}
     * @memberof JournalEntry
     */
    'modifiedBy'?: number;
    /**
     * 
     * @type {number}
     * @memberof JournalEntry
     */
    'approvedBy'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof JournalEntry
     */
    'voidedBy'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof JournalEntry
     */
    'galleryId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof JournalEntry
     */
    'contactId'?: number | null;
    /**
     * 
     * @type {RunningNumberType}
     * @memberof JournalEntry
     */
    'runningNumberType'?: RunningNumberType | null;
    /**
     * 
     * @type {number}
     * @memberof JournalEntry
     */
    'fiscalYearId'?: number | null;
    /**
     * 
     * @type {Gallery}
     * @memberof JournalEntry
     */
    'gallery'?: Gallery | null;
    /**
     * 
     * @type {Company}
     * @memberof JournalEntry
     */
    'company'?: Company | null;
    /**
     * 
     * @type {User}
     * @memberof JournalEntry
     */
    'approvedByUser'?: User | null;
    /**
     * 
     * @type {User}
     * @memberof JournalEntry
     */
    'modifiedByUser'?: User | null;
    /**
     * 
     * @type {User}
     * @memberof JournalEntry
     */
    'voidedByUser'?: User | null;
    /**
     * 
     * @type {string}
     * @memberof JournalEntry
     */
    'remarks'?: string | null;
    /**
     * 
     * @type {Contact}
     * @memberof JournalEntry
     */
    'contact'?: Contact | null;
    /**
     * 
     * @type {FiscalYear}
     * @memberof JournalEntry
     */
    'fiscalYear'?: FiscalYear | null;
    /**
     * 
     * @type {string}
     * @memberof JournalEntry
     */
    'reference'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof JournalEntry
     */
    'referenceId'?: number | null;
    /**
     * 
     * @type {DocumentTypes}
     * @memberof JournalEntry
     */
    'referenceDocumentType'?: DocumentTypes | null;
    /**
     * 
     * @type {boolean}
     * @memberof JournalEntry
     */
    'isSystemDocument': boolean;
    /**
     * 
     * @type {RuleCompileStatus}
     * @memberof JournalEntry
     */
    'ruleCompileStatus'?: RuleCompileStatus;
    /**
     * 
     * @type {Array<IBookOfAccount>}
     * @memberof JournalEntry
     */
    'bookOfAccounts'?: Array<IBookOfAccount> | null;
    /**
     * 
     * @type {boolean}
     * @memberof JournalEntry
     */
    'isChangedDocumentDate'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof JournalEntry
     */
    'isResetDocument'?: boolean;
}
/**
 * 0 = Delete 1 = Awaiting 5 = Approved 9 = Void
 * @export
 * @enum {string}
 */

export const JournalEntryStatus = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_5: 5,
    NUMBER_9: 9
} as const;

export type JournalEntryStatus = typeof JournalEntryStatus[keyof typeof JournalEntryStatus];


/**
 * 1 = Default 3 = DocumentCreated 5 = Payment 7 = ChequeDate 9 = TaxNoRefund 11 = VATManagementHistory
 * @export
 * @enum {string}
 */

export const JournalEntryTemplateType = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7,
    NUMBER_9: 9,
    NUMBER_11: 11
} as const;

export type JournalEntryTemplateType = typeof JournalEntryTemplateType[keyof typeof JournalEntryTemplateType];


/**
 * 1 = PCT 3 = PPA 5 = PPB
 * @export
 * @enum {string}
 */

export const KConnectProductCode = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5
} as const;

export type KConnectProductCode = typeof KConnectProductCode[keyof typeof KConnectProductCode];


/**
 * 
 * @export
 * @interface ListItem
 */
export interface ListItem {
    /**
     * 
     * @type {string}
     * @memberof ListItem
     */
    'text'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListItem
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface Media
 */
export interface Media {
    /**
     * 
     * @type {number}
     * @memberof Media
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Media
     */
    'orderNumber'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'createdOn'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Media
     */
    'isDisplay'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Media
     */
    'isDeleted'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Media
     */
    'galleryId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Media
     */
    'mediaType'?: number;
    /**
     * 
     * @type {number}
     * @memberof Media
     */
    'companyId'?: number;
    /**
     * 
     * @type {number}
     * @memberof Media
     */
    'userId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'path'?: string | null;
    /**
     * 
     * @type {Company}
     * @memberof Media
     */
    'company'?: Company | null;
    /**
     * 
     * @type {Gallery}
     * @memberof Media
     */
    'gallery'?: Gallery | null;
    /**
     * 
     * @type {User}
     * @memberof Media
     */
    'user'?: User | null;
}
/**
 * 
 * @export
 * @interface MessageSent
 */
export interface MessageSent {
    /**
     * 
     * @type {string}
     * @memberof MessageSent
     */
    'messageId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MessageSent
     */
    'externalDocumentId'?: string | null;
}
/**
 * Represents an ObjectId (see also BsonObjectId).
 * @export
 * @interface ObjectId
 */
export interface ObjectId {
    /**
     * Gets the timestamp.
     * @type {number}
     * @memberof ObjectId
     */
    'Timestamp'?: number;
    /**
     * Gets the machine.
     * @type {number}
     * @memberof ObjectId
     * @deprecated
     */
    'Machine'?: number;
    /**
     * Gets the PID.
     * @type {number}
     * @memberof ObjectId
     * @deprecated
     */
    'Pid'?: number;
    /**
     * Gets the increment.
     * @type {number}
     * @memberof ObjectId
     * @deprecated
     */
    'Increment'?: number;
    /**
     * Gets the creation time (derived from the timestamp).
     * @type {string}
     * @memberof ObjectId
     */
    'CreationTime'?: string;
}
/**
 * 1 = Asc 3 = Desc
 * @export
 * @enum {string}
 */

export const OrderBy = {
    NUMBER_1: 1,
    NUMBER_3: 3
} as const;

export type OrderBy = typeof OrderBy[keyof typeof OrderBy];


/**
 * 
 * @export
 * @interface OtherChannels
 */
export interface OtherChannels {
    /**
     * 
     * @type {number}
     * @memberof OtherChannels
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof OtherChannels
     */
    'companyId': number;
    /**
     * 
     * @type {number}
     * @memberof OtherChannels
     */
    'chartOfAccountId'?: number | null;
    /**
     * 
     * @type {ChartOfAccount}
     * @memberof OtherChannels
     */
    'chartOfAccount'?: ChartOfAccount | null;
    /**
     * 
     * @type {string}
     * @memberof OtherChannels
     */
    'name'?: string | null;
    /**
     * 
     * @type {BankingChannelsStatus}
     * @memberof OtherChannels
     */
    'status'?: BankingChannelsStatus;
    /**
     * 
     * @type {PaymentChannelsType}
     * @memberof OtherChannels
     */
    'channel'?: PaymentChannelsType;
    /**
     * 
     * @type {OtherChannelsType}
     * @memberof OtherChannels
     */
    'type'?: OtherChannelsType;
    /**
     * 
     * @type {string}
     * @memberof OtherChannels
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OtherChannels
     */
    'bankId'?: number | null;
    /**
     * 
     * @type {Bank}
     * @memberof OtherChannels
     */
    'bank'?: Bank | null;
    /**
     * 
     * @type {string}
     * @memberof OtherChannels
     */
    'bankName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OtherChannels
     */
    'createdOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof OtherChannels
     */
    'modifiedOn'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OtherChannels
     */
    'isDelete'?: boolean;
}
/**
 * 1 = Receive 3 = ReceivePay 5 = Pay
 * @export
 * @enum {string}
 */

export const OtherChannelsType = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5
} as const;

export type OtherChannelsType = typeof OtherChannelsType[keyof typeof OtherChannelsType];


/**
 * 
 * @export
 * @interface PackageList
 */
export interface PackageList {
    /**
     * 
     * @type {number}
     * @memberof PackageList
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PackageList
     */
    'packageName': string;
    /**
     * 
     * @type {string}
     * @memberof PackageList
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PackageList
     */
    'configuration': string;
    /**
     * 
     * @type {string}
     * @memberof PackageList
     */
    'remarks'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PackageList
     */
    'displayNameTH'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PackageList
     */
    'displayNameEN'?: string | null;
}
/**
 * 10 = Pending 30 = Approve 50 = Suspend 70 = Terminated 90 = Delete
 * @export
 * @enum {string}
 */

export const PackageStatus = {
    NUMBER_10: 10,
    NUMBER_30: 30,
    NUMBER_50: 50,
    NUMBER_70: 70,
    NUMBER_90: 90
} as const;

export type PackageStatus = typeof PackageStatus[keyof typeof PackageStatus];


/**
 * 1 = Monthly 3 = Daily
 * @export
 * @enum {string}
 */

export const PaidPeriod = {
    NUMBER_1: 1,
    NUMBER_3: 3
} as const;

export type PaidPeriod = typeof PaidPeriod[keyof typeof PaidPeriod];


/**
 * 0 = Default 1 = None 3 = Quantity 5 = Price 7 = Percentage 11 = RECPartial
 * @export
 * @enum {string}
 */

export const PartialPaymentMethod = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7,
    NUMBER_11: 11
} as const;

export type PartialPaymentMethod = typeof PartialPaymentMethod[keyof typeof PartialPaymentMethod];


/**
 * 1 = Omise 3 = InAppIOS 5 = InAppAndriod 7 = UssdAis 9 = BankTranfer 11 = PrePaidSerial
 * @export
 * @enum {string}
 */

export const PaymentChannel = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7,
    NUMBER_9: 9,
    NUMBER_11: 11
} as const;

export type PaymentChannel = typeof PaymentChannel[keyof typeof PaymentChannel];


/**
 * 1 = POS 3 = PayemntGateWay 5 = EDC 7 = ECommerce
 * @export
 * @enum {string}
 */

export const PaymentChannelsType = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7
} as const;

export type PaymentChannelsType = typeof PaymentChannelsType[keyof typeof PaymentChannelsType];


/**
 * 0 = None 1 = Cash 3 = Cheque 5 = Transfer 7 = CreditCard 9 = PushPay 11 = PettyCash 13 = Other 51 = TransferByKConnect
 * @export
 * @enum {string}
 */

export const PaymentMethod = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7,
    NUMBER_9: 9,
    NUMBER_11: 11,
    NUMBER_13: 13,
    NUMBER_51: 51
} as const;

export type PaymentMethod = typeof PaymentMethod[keyof typeof PaymentMethod];


/**
 * 
 * @export
 * @interface PaymentModel
 */
export interface PaymentModel {
    /**
     * 
     * @type {string}
     * @memberof PaymentModel
     */
    'cashRemarks'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'excludeVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'cashTax'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaymentModel
     */
    'creditCardNumber'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'companyVatRate'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'net'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaymentModel
     */
    'bankAccountNumber'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'bankAccountId'?: number | null;
    /**
     * 
     * @type {PaymentMethod}
     * @memberof PaymentModel
     */
    'paymentMethod'?: PaymentMethod;
    /**
     * 
     * @type {string}
     * @memberof PaymentModel
     */
    'dateNow'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'amountCollected'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'amountWithheld'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'withholdingTax'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentModel
     */
    'remarks'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'transferBankAccountId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'bankAccountCreditCardId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'charge'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaymentModel
     */
    'chequeDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentModel
     */
    'chequeNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentModel
     */
    'chequeBankAccountId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentModel
     */
    'creditCardBankAccountId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'remainingCollected'?: number | null;
    /**
     * 
     * @type {RemainingCollectedType}
     * @memberof PaymentModel
     */
    'remainingCollectedType'?: RemainingCollectedType | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'deductionAmount'?: number | null;
    /**
     * 
     * @type {DeductionType}
     * @memberof PaymentModel
     */
    'paymentDeductionType'?: DeductionType | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentModel
     */
    'pettyCashName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'pettyCashId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'chequeId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'creditCardId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'otherChannelId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentModel
     */
    'chequeDepositDate'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'chequeDepositBankId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentModel
     */
    'chequeCashingDate'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentModel
     */
    'autoCreateWithholdingTax'?: boolean;
    /**
     * 
     * @type {IncomeType}
     * @memberof PaymentModel
     */
    'withholdingTaxIncomeType'?: IncomeType;
    /**
     * 
     * @type {string}
     * @memberof PaymentModel
     */
    'withholdingTaxIncomeDescription'?: string | null;
    /**
     * 
     * @type {Entity}
     * @memberof PaymentModel
     */
    'withholdingTaxEntity'?: Entity;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'exchangeRateFee'?: number | null;
}
/**
 * 
 * @export
 * @interface Payroll
 */
export interface Payroll {
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'companyId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Payroll
     */
    'startDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Payroll
     */
    'endDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'paymentCycle'?: number;
    /**
     * 
     * @type {PayrollStatus}
     * @memberof Payroll
     */
    'status'?: PayrollStatus;
    /**
     * 
     * @type {boolean}
     * @memberof Payroll
     */
    'isDelete'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Payroll
     */
    'createdOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Payroll
     */
    'modifiedOn'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'createdBy'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'modifiedBy'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'expenseId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'galleryId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Payroll
     */
    'remarks'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'total'?: number;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'bankId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Payroll
     */
    'accountNumber'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'addAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'deductAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'netTotal'?: number;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'runningNumberType'?: number;
    /**
     * 
     * @type {string}
     * @memberof Payroll
     */
    'datePayment'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Payroll
     */
    'documentDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'totalPayrollCash'?: number;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'totalPayrollTransfer'?: number;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'fee'?: number;
    /**
     * 
     * @type {string}
     * @memberof Payroll
     */
    'paymentRemarks'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Payroll
     */
    'employerAccountNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Payroll
     */
    'employerAccountBranch'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'bankAccountId'?: number | null;
    /**
     * 
     * @type {BankAccountType}
     * @memberof Payroll
     */
    'accountType'?: BankAccountType | null;
    /**
     * 
     * @type {string}
     * @memberof Payroll
     */
    'referenceId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'payrollVersion'?: number;
    /**
     * 
     * @type {Company}
     * @memberof Payroll
     */
    'company'?: Company | null;
    /**
     * 
     * @type {User}
     * @memberof Payroll
     */
    'createdByUser'?: User | null;
    /**
     * 
     * @type {User}
     * @memberof Payroll
     */
    'modifiedByUser'?: User | null;
    /**
     * 
     * @type {Array<PayrollDetail>}
     * @memberof Payroll
     */
    'payrollDetail'?: Array<PayrollDetail> | null;
    /**
     * 
     * @type {Gallery}
     * @memberof Payroll
     */
    'gallery'?: Gallery | null;
    /**
     * 
     * @type {boolean}
     * @memberof Payroll
     */
    'isMigrate'?: boolean;
    /**
     * 
     * @type {RuleCompileStatus}
     * @memberof Payroll
     */
    'ruleCompileStatus'?: RuleCompileStatus;
    /**
     * 
     * @type {boolean}
     * @memberof Payroll
     */
    'isPartialPayments'?: boolean;
    /**
     * 
     * @type {PaidPeriod}
     * @memberof Payroll
     */
    'paidPeriod'?: PaidPeriod;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'socialSecurityPercent'?: number;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'statusInt'?: number;
}
/**
 * 
 * @export
 * @interface PayrollDetail
 */
export interface PayrollDetail {
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'payrollId'?: number;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'employeeId'?: number;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'salary'?: number;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'socialSecurityValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'commission'?: number;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'bonus'?: number;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'deduction'?: number;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'withholdingTax'?: number;
    /**
     * 
     * @type {PayrollDetailStatus}
     * @memberof PayrollDetail
     */
    'status'?: PayrollDetailStatus;
    /**
     * 
     * @type {boolean}
     * @memberof PayrollDetail
     */
    'isDelete'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'withheld'?: number;
    /**
     * 
     * @type {string}
     * @memberof PayrollDetail
     */
    'datePayment'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'fee'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PayrollDetail
     */
    'ref'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PayrollDetail
     */
    'transactionId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'amount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'payStatus'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PayrollDetail
     */
    'remarks'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'expenseId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'overtime'?: number;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'advance'?: number;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'otherAddition'?: number;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'otherDeduction'?: number;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'providentFund'?: number;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'securityMoney'?: number;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'value'?: number;
    /**
     * 
     * @type {string}
     * @memberof PayrollDetail
     */
    'note'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PayrollDetail
     */
    'createdOn'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'createdBy'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PayrollDetail
     */
    'modifiedOn'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'lastModifiedBy'?: number;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'employerSocialSecurity'?: number;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'allowance'?: number;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'cola'?: number;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'medicalExpense'?: number;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'accommodation'?: number;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'directorRemuneration'?: number;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'methodPayment'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'bankId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PayrollDetail
     */
    'accountNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PayrollDetail
     */
    'accountNumberMasking'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PayrollDetail
     */
    'employeeTitle'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PayrollDetail
     */
    'employeeCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PayrollDetail
     */
    'employeeFirstName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PayrollDetail
     */
    'employeeLastName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PayrollDetail
     */
    'employeeFirstNameForeign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PayrollDetail
     */
    'employeeLastNameForeign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PayrollDetail
     */
    'employeeStartDate'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PayrollDetail
     */
    'isSocialSecurityRegistered'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PayrollDetail
     */
    'bankBranchCode'?: string | null;
    /**
     * 
     * @type {BankAccountType}
     * @memberof PayrollDetail
     */
    'accountType'?: BankAccountType | null;
    /**
     * 
     * @type {string}
     * @memberof PayrollDetail
     */
    'referenceId'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PayrollDetail
     */
    'isMigrate'?: boolean;
    /**
     * 
     * @type {Employee}
     * @memberof PayrollDetail
     */
    'employee'?: Employee | null;
    /**
     * 
     * @type {ExpenseList}
     * @memberof PayrollDetail
     */
    'expenseList'?: ExpenseList | null;
    /**
     * 
     * @type {Payroll}
     * @memberof PayrollDetail
     */
    'payroll'?: Payroll | null;
    /**
     * 
     * @type {Bank}
     * @memberof PayrollDetail
     */
    'bank'?: Bank | null;
    /**
     * 
     * @type {User}
     * @memberof PayrollDetail
     */
    'lastModifiedByUser'?: User | null;
    /**
     * 
     * @type {RuleCompileStatus}
     * @memberof PayrollDetail
     */
    'ruleCompileStatus'?: RuleCompileStatus;
    /**
     * 
     * @type {string}
     * @memberof PayrollDetail
     */
    'employerAccountBranch'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PayrollDetail
     */
    'employerAccountNumber'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'bankAccountId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PayrollDetail
     */
    'paymentRemarks'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'payrollPaymentId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'kcProcessingStatus'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'departmentId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PayrollDetail
     */
    'departmentName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PayrollDetail
     */
    'departmentCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'workDays'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'wage'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PayrollDetail
     */
    'isSocialSecurityAutoCal'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'socialSecurityPercent'?: number;
    /**
     * 
     * @type {SendEmailStatus}
     * @memberof PayrollDetail
     */
    'sendEmailStatus'?: SendEmailStatus | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'studentLoan'?: number;
    /**
     * 
     * @type {ConditionsOfWithholdingTax}
     * @memberof PayrollDetail
     */
    'conditionsWithholdingTax'?: ConditionsOfWithholdingTax | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'overtimePND'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'commissionPND'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'bonusPND'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'allowancePND'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'colaPND'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'medicalExpensePND'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'accommodationPND'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'directorRemunerationPND'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'otherAdditionPND'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'withholdingTax401'?: number;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'withholdingTax402'?: number;
    /**
     * 
     * @type {number}
     * @memberof PayrollDetail
     */
    'statusInt'?: number;
}
/**
 * 0 = Draft 1 = Awaiting 2 = Reset 3 = Paid 4 = Partial 5 = Rejected 7 = Approved 11 = PushPayAwaiting 13 = PushPayProcessed 15 = PushPayRejected 17 = PushPayPartial 19 = PushPayPendingPayments 50 = KConnectAwaiting 52 = KConnectProcessed 54 = KConnectRejected 56 = KConnectPendingPayments 58 = KConnectPartialPayments
 * @export
 * @enum {string}
 */

export const PayrollDetailStatus = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_7: 7,
    NUMBER_11: 11,
    NUMBER_13: 13,
    NUMBER_15: 15,
    NUMBER_17: 17,
    NUMBER_19: 19,
    NUMBER_50: 50,
    NUMBER_52: 52,
    NUMBER_54: 54,
    NUMBER_56: 56,
    NUMBER_58: 58
} as const;

export type PayrollDetailStatus = typeof PayrollDetailStatus[keyof typeof PayrollDetailStatus];


/**
 * 
 * @export
 * @interface PayrollPreferences
 */
export interface PayrollPreferences {
    /**
     * 
     * @type {number}
     * @memberof PayrollPreferences
     */
    'companyId'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PayrollPreferences
     */
    'isSocialSecurityRegistered'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PayrollPreferences
     */
    'employerAccountNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PayrollPreferences
     */
    'employerAccountBranch'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PayrollPreferences
     */
    'kCorporateClientCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PayrollPreferences
     */
    'kCorporateAccountNumber'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollPreferences
     */
    'payrollBankAccountId'?: number | null;
    /**
     * 
     * @type {KConnectProductCode}
     * @memberof PayrollPreferences
     */
    'kConnect_ProductCode'?: KConnectProductCode;
    /**
     * 
     * @type {number}
     * @memberof PayrollPreferences
     */
    'overtimePND'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollPreferences
     */
    'commissionPND'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollPreferences
     */
    'bonusPND'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollPreferences
     */
    'allowancePND'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollPreferences
     */
    'colaPND'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollPreferences
     */
    'medicalExpensePND'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollPreferences
     */
    'accommodationPND'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollPreferences
     */
    'directorRemunerationPND'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollPreferences
     */
    'otherAdditionPND'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PayrollPreferences
     */
    'accessKConnect'?: boolean;
}
/**
 * 
 * @export
 * @interface PayrollQuery
 */
export interface PayrollQuery {
    /**
     * 
     * @type {number}
     * @memberof PayrollQuery
     */
    'pageSize'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollQuery
     */
    'currentPage'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollQuery
     */
    'totalRecords'?: number;
    /**
     * 
     * @type {DateType}
     * @memberof PayrollQuery
     */
    'dateType'?: DateType;
    /**
     * 
     * @type {string}
     * @memberof PayrollQuery
     */
    'startDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PayrollQuery
     */
    'endDate'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollQuery
     */
    'day'?: number;
    /**
     * 
     * @type {number}
     * @memberof PayrollQuery
     */
    'month'?: number;
    /**
     * 
     * @type {number}
     * @memberof PayrollQuery
     */
    'year'?: number;
    /**
     * 
     * @type {DataRange}
     * @memberof PayrollQuery
     */
    'range'?: DataRange;
    /**
     * 
     * @type {number}
     * @memberof PayrollQuery
     */
    'isFirstCurrent'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof PayrollQuery
     */
    'hashTags'?: Array<string> | null;
    /**
     * 
     * @type {ReportTypes}
     * @memberof PayrollQuery
     */
    'reportType'?: ReportTypes;
    /**
     * 
     * @type {Array<FilterOptions>}
     * @memberof PayrollQuery
     */
    'filter'?: Array<FilterOptions> | null;
    /**
     * 
     * @type {Array<SortOptions>}
     * @memberof PayrollQuery
     */
    'sortBy'?: Array<SortOptions> | null;
    /**
     * 
     * @type {number}
     * @memberof PayrollQuery
     */
    'totalValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof PayrollQuery
     */
    'totalVAT'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PayrollQuery
     */
    'isReceived'?: boolean;
    /**
     * 
     * @type {Array<DocumentTypes>}
     * @memberof PayrollQuery
     */
    'documentType'?: Array<DocumentTypes> | null;
    /**
     * 
     * @type {Array<ListItem>}
     * @memberof PayrollQuery
     */
    'revenue'?: Array<ListItem> | null;
    /**
     * 
     * @type {Array<ListItem>}
     * @memberof PayrollQuery
     */
    'expenses'?: Array<ListItem> | null;
    /**
     * 
     * @type {Array<ListItem>}
     * @memberof PayrollQuery
     */
    'previousMonths'?: Array<ListItem> | null;
    /**
     * 
     * @type {Array<ListItem>}
     * @memberof PayrollQuery
     */
    'previousYears'?: Array<ListItem> | null;
    /**
     * 
     * @type {Array<CustomDocumentModel>}
     * @memberof PayrollQuery
     */
    'customDocumentModels'?: Array<CustomDocumentModel> | null;
    /**
     * 
     * @type {boolean}
     * @memberof PayrollQuery
     */
    'fromPayroll'?: boolean;
    /**
     * 
     * @type {PayrollType}
     * @memberof PayrollQuery
     */
    'payrollType'?: PayrollType;
}
/**
 * 
 * @export
 * @interface PayrollQueryAllOf
 */
export interface PayrollQueryAllOf {
    /**
     * 
     * @type {boolean}
     * @memberof PayrollQueryAllOf
     */
    'fromPayroll'?: boolean;
    /**
     * 
     * @type {PayrollType}
     * @memberof PayrollQueryAllOf
     */
    'payrollType'?: PayrollType;
}
/**
 * 0 = Draft 1 = Awaiting 2 = Reset 3 = Paid 4 = Partial 5 = Rejected 7 = Approved 11 = PushPayAwaiting 13 = PushPayProcessed 15 = PushPayRejected 17 = PushPayPartial 19 = PushPayPendingPayments 50 = KConnectAwaiting 52 = KConnectProcessed 54 = KConnectRejected 56 = KConnectPendingPayments
 * @export
 * @enum {string}
 */

export const PayrollStatus = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_7: 7,
    NUMBER_11: 11,
    NUMBER_13: 13,
    NUMBER_15: 15,
    NUMBER_17: 17,
    NUMBER_19: 19,
    NUMBER_50: 50,
    NUMBER_52: 52,
    NUMBER_54: 54,
    NUMBER_56: 56
} as const;

export type PayrollStatus = typeof PayrollStatus[keyof typeof PayrollStatus];


/**
 * 1 = FirstVersion 3 = PayrollPayment 5 = Kconnect 7 = Cash 9 = Transfer
 * @export
 * @enum {string}
 */

export const PayrollType = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7,
    NUMBER_9: 9
} as const;

export type PayrollType = typeof PayrollType[keyof typeof PayrollType];


/**
 * 
 * @export
 * @interface PettyCash
 */
export interface PettyCash {
    /**
     * 
     * @type {number}
     * @memberof PettyCash
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PettyCash
     */
    'companyId': number;
    /**
     * 
     * @type {string}
     * @memberof PettyCash
     */
    'createdOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof PettyCash
     */
    'modifiedOn'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PettyCash
     */
    'isDelete'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PettyCash
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PettyCash
     */
    'name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PettyCash
     */
    'cashLimit'?: number;
    /**
     * 
     * @type {number}
     * @memberof PettyCash
     */
    'chartOfAccountId'?: number | null;
    /**
     * 
     * @type {ChartOfAccount}
     * @memberof PettyCash
     */
    'chartOfAccount'?: ChartOfAccount | null;
    /**
     * 
     * @type {number}
     * @memberof PettyCash
     */
    'cashHolderId'?: number;
    /**
     * 
     * @type {User}
     * @memberof PettyCash
     */
    'cashHolder'?: User | null;
    /**
     * 
     * @type {BankingChannelsStatus}
     * @memberof PettyCash
     */
    'status'?: BankingChannelsStatus;
    /**
     * 
     * @type {string}
     * @memberof PettyCash
     */
    'cashHolderName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PettyCash
     */
    'remainingBalance'?: number;
}
/**
 * 0 = Or 1 = And
 * @export
 * @enum {string}
 */

export const PredicateOperator = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type PredicateOperator = typeof PredicateOperator[keyof typeof PredicateOperator];


/**
 * 
 * @export
 * @interface ProductCategory
 */
export interface ProductCategory {
    /**
     * 
     * @type {number}
     * @memberof ProductCategory
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductCategory
     */
    'name'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ProductCategory
     */
    'isDelete'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProductCategory
     */
    'isShare'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ProductCategory
     */
    'resetTransactionId'?: number | null;
}
/**
 * 
 * @export
 * @interface ProductItem
 */
export interface ProductItem {
    /**
     * 
     * @type {number}
     * @memberof ProductItem
     */
    'type'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductItem
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductItem
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ProductItem
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductItem
     */
    'unitName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ProductItem
     */
    'pricePerUnit'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductItem
     */
    'total'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductItem
     */
    'sellChartOfAccountCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductItem
     */
    'buyChartOfAccountCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductItem
     */
    'productCode'?: string | null;
}
/**
 * 
 * @export
 * @interface ProductList
 */
export interface ProductList {
    /**
     * 
     * @type {number}
     * @memberof ProductList
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductList
     */
    'barCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductList
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProductList
     */
    'unitMeasurement'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ProductList
     */
    'unitPrice'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ProductList
     */
    'unitPriceWithVat'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ProductList
     */
    'unitWeight'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ProductList
     */
    'categoryId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ProductList
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductList
     */
    'remarks'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ProductList
     */
    'galleryId'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ProductList
     */
    'isVat'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ProductList
     */
    'mainUnitId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ProductList
     */
    'subUnitId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ProductList
     */
    'mainUnitAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductList
     */
    'subUnitAmount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ProductList
     */
    'hasStock'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProductList
     */
    'productCode'?: string | null;
    /**
     * 
     * @type {ProductTypes}
     * @memberof ProductList
     */
    'type'?: ProductTypes;
    /**
     * 
     * @type {number}
     * @memberof ProductList
     */
    'buyPrice'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ProductList
     */
    'buyPriceWithVat'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ProductList
     */
    'isBuyVat'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProductList
     */
    'allowOverSold'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProductList
     */
    'image'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ProductList
     */
    'isDelete'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ProductList
     */
    'vatRate'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductList
     */
    'buyVatRate'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductList
     */
    'resetTransactionId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ProductList
     */
    'createdOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductList
     */
    'modifiedOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductList
     */
    'broughtForwardOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductList
     */
    'buyDescription'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ProductList
     */
    'buyChartOfAccountId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ProductList
     */
    'sellChartOfAccountId'?: number | null;
    /**
     * 
     * @type {ProductNonInventoryType}
     * @memberof ProductList
     */
    'productNonInventoryType'?: ProductNonInventoryType | null;
    /**
     * 
     * @type {string}
     * @memberof ProductList
     */
    'transactionId'?: string | null;
    /**
     * 
     * @type {ProductUnit}
     * @memberof ProductList
     */
    'productMainUnit'?: ProductUnit | null;
    /**
     * 
     * @type {ProductUnit}
     * @memberof ProductList
     */
    'productSubUnit'?: ProductUnit | null;
    /**
     * 
     * @type {ProductCategory}
     * @memberof ProductList
     */
    'productCategory'?: ProductCategory | null;
    /**
     * 
     * @type {boolean}
     * @memberof ProductList
     */
    'isMigrate'?: boolean;
}
/**
 * 1 = NonStockProduct 3 = SparepartProduct 5 = SampleProduct 7 = FreemiumProduct 9 = SupplyProduct 11 = OthersProduct
 * @export
 * @enum {string}
 */

export const ProductNonInventoryType = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7,
    NUMBER_9: 9,
    NUMBER_11: 11
} as const;

export type ProductNonInventoryType = typeof ProductNonInventoryType[keyof typeof ProductNonInventoryType];


/**
 * 
 * @export
 * @interface ProductResult
 */
export interface ProductResult {
    /**
     * 
     * @type {number}
     * @memberof ProductResult
     */
    'id'?: number;
    /**
     * 
     * @type {ProductTypes}
     * @memberof ProductResult
     */
    'type'?: ProductTypes;
    /**
     * 
     * @type {string}
     * @memberof ProductResult
     */
    'code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductResult
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductResult
     */
    'barcode'?: string | null;
    /**
     * 
     * @type {ImageResult}
     * @memberof ProductResult
     */
    'image'?: ImageResult | null;
    /**
     * 
     * @type {VatTypes}
     * @memberof ProductResult
     */
    'buyVatType'?: VatTypes;
    /**
     * 
     * @type {number}
     * @memberof ProductResult
     */
    'buyPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductResult
     */
    'buyPriceWithVat'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductResult
     */
    'buyDescription'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ProductResult
     */
    'buyChartOfAccountId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ProductResult
     */
    'buyChartOfAccountCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductResult
     */
    'buyChartOfAccountNameLocal'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductResult
     */
    'buyChartOfAccountNameForeign'?: string | null;
    /**
     * 
     * @type {VatTypes}
     * @memberof ProductResult
     */
    'sellVatType'?: VatTypes;
    /**
     * 
     * @type {number}
     * @memberof ProductResult
     */
    'sellPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductResult
     */
    'sellPriceWithVat'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductResult
     */
    'sellDescription'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ProductResult
     */
    'sellChartOfAccountId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ProductResult
     */
    'sellChartOfAccountCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductResult
     */
    'sellChartOfAccountNameLocal'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductResult
     */
    'sellChartOfAccountNameForeign'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ProductResult
     */
    'categoryId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ProductResult
     */
    'categoryName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ProductResult
     */
    'unitId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ProductResult
     */
    'unitName'?: string | null;
    /**
     * 
     * @type {ProductNonInventoryType}
     * @memberof ProductResult
     */
    'productNonInventoryType'?: ProductNonInventoryType | null;
    /**
     * 
     * @type {string}
     * @memberof ProductResult
     */
    'broughtForwardOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductResult
     */
    'inventoryPublishedOn'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ProductResult
     */
    'inventoryQuantity'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ProductResult
     */
    'inventoryPrice'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ProductResult
     */
    'inventoryTotal'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ProductResult
     */
    'inventoryRemark'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ProductResult
     */
    'averageBuyPrice'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ProductResult
     */
    'averageSellPrice'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ProductResult
     */
    'remainingStock'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ProductResult
     */
    'totalValueInHand'?: number | null;
    /**
     * 
     * @type {Array<IStockCard>}
     * @memberof ProductResult
     */
    'stockCard'?: Array<IStockCard> | null;
}
/**
 * 1 = Service 3 = ProductWithNoStock 5 = ProductWithStock
 * @export
 * @enum {string}
 */

export const ProductTypes = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5
} as const;

export type ProductTypes = typeof ProductTypes[keyof typeof ProductTypes];


/**
 * 
 * @export
 * @interface ProductUnit
 */
export interface ProductUnit {
    /**
     * 
     * @type {number}
     * @memberof ProductUnit
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductUnit
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProductUnit
     */
    'isShare'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProductUnit
     */
    'isDelete'?: boolean;
}
/**
 * 
 * @export
 * @interface ReceivableInvoice
 */
export interface ReceivableInvoice {
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoice
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoice
     */
    'contactId'?: number;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoice
     */
    'companyId': number;
    /**
     * 
     * @type {ReceivableInvoiceStatus}
     * @memberof ReceivableInvoice
     */
    'status'?: ReceivableInvoiceStatus;
    /**
     * 
     * @type {string}
     * @memberof ReceivableInvoice
     */
    'createdOn': string;
    /**
     * 
     * @type {string}
     * @memberof ReceivableInvoice
     */
    'modifiedOn': string;
    /**
     * 
     * @type {string}
     * @memberof ReceivableInvoice
     */
    'publishedOn': string;
    /**
     * 
     * @type {string}
     * @memberof ReceivableInvoice
     */
    'documentDate': string;
    /**
     * 
     * @type {boolean}
     * @memberof ReceivableInvoice
     */
    'published'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ReceivableInvoice
     */
    'approved'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoice
     */
    'approvedBy'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoice
     */
    'approvedByClientId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ReceivableInvoice
     */
    'approvedImageUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ReceivableInvoice
     */
    'documentSerial'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ReceivableInvoice
     */
    'remarks'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ReceivableInvoice
     */
    'name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoice
     */
    'value'?: number;
    /**
     * 
     * @type {string}
     * @memberof ReceivableInvoice
     */
    'dueDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ReceivableInvoice
     */
    'expectedDate'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoice
     */
    'createdBy'?: number;
    /**
     * 
     * @type {string}
     * @memberof ReceivableInvoice
     */
    'documentId'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ReceivableInvoice
     */
    'isDelete'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoice
     */
    'vatRate'?: number;
    /**
     * 
     * @type {string}
     * @memberof ReceivableInvoice
     */
    'internalNotes'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoice
     */
    'galleryId'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ReceivableInvoice
     */
    'isVatInclusive'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoice
     */
    'salesId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ReceivableInvoice
     */
    'salesName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoice
     */
    'roundingAdjustment'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ReceivableInvoice
     */
    'isInlineDiscount'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ReceivableInvoice
     */
    'isInlineVat'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoice
     */
    'tax'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoice
     */
    'documentSerialNoPrefix'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoice
     */
    'vatValue'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoice
     */
    'resetTransactionId'?: number | null;
    /**
     * 
     * @type {Contact}
     * @memberof ReceivableInvoice
     */
    'contact'?: Contact | null;
    /**
     * 
     * @type {User}
     * @memberof ReceivableInvoice
     */
    'approvedByClient'?: User | null;
    /**
     * 
     * @type {Company}
     * @memberof ReceivableInvoice
     */
    'company'?: Company | null;
    /**
     * 
     * @type {User}
     * @memberof ReceivableInvoice
     */
    'createdByUser'?: User | null;
    /**
     * 
     * @type {User}
     * @memberof ReceivableInvoice
     */
    'approvedByUser'?: User | null;
    /**
     * 
     * @type {User}
     * @memberof ReceivableInvoice
     */
    'sales'?: User | null;
    /**
     * 
     * @type {Gallery}
     * @memberof ReceivableInvoice
     */
    'gallery'?: Gallery | null;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoice
     */
    'inlineVatValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoice
     */
    'inlineDiscountValue'?: number;
    /**
     * 
     * @type {RuleCompileStatus}
     * @memberof ReceivableInvoice
     */
    'ruleCompileStatus'?: RuleCompileStatus;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoice
     */
    'runningNumberType'?: number;
    /**
     * 
     * @type {string}
     * @memberof ReceivableInvoice
     */
    'runningModifiedOn'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoice
     */
    'exemptAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoice
     */
    'vatableAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoice
     */
    'totalAfterDiscount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoice
     */
    'subTotal'?: number;
    /**
     * 
     * @type {Array<IDocumentReference>}
     * @memberof ReceivableInvoice
     */
    'documentReferences'?: Array<IDocumentReference> | null;
    /**
     * 
     * @type {Array<IDocumentReference>}
     * @memberof ReceivableInvoice
     */
    'referencedToMe'?: Array<IDocumentReference> | null;
    /**
     * 
     * @type {Array<IDocumentReference>}
     * @memberof ReceivableInvoice
     */
    'referencedByMe'?: Array<IDocumentReference> | null;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoice
     */
    'statusInt'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ReceivableInvoice
     */
    'isReCalculate'?: boolean;
    /**
     * 
     * @type {PartialPaymentMethod}
     * @memberof ReceivableInvoice
     */
    'partialPaymentMethod'?: PartialPaymentMethod | null;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoice
     */
    'vatAmount'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ReceivableInvoice
     */
    'isMigrate'?: boolean;
}
/**
 * 
 * @export
 * @interface ReceivableInvoiceAllOf
 */
export interface ReceivableInvoiceAllOf {
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoiceAllOf
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoiceAllOf
     */
    'contactId'?: number;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoiceAllOf
     */
    'companyId': number;
    /**
     * 
     * @type {ReceivableInvoiceStatus}
     * @memberof ReceivableInvoiceAllOf
     */
    'status'?: ReceivableInvoiceStatus;
    /**
     * 
     * @type {string}
     * @memberof ReceivableInvoiceAllOf
     */
    'createdOn': string;
    /**
     * 
     * @type {string}
     * @memberof ReceivableInvoiceAllOf
     */
    'modifiedOn': string;
    /**
     * 
     * @type {string}
     * @memberof ReceivableInvoiceAllOf
     */
    'publishedOn': string;
    /**
     * 
     * @type {string}
     * @memberof ReceivableInvoiceAllOf
     */
    'documentDate': string;
    /**
     * 
     * @type {boolean}
     * @memberof ReceivableInvoiceAllOf
     */
    'published'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ReceivableInvoiceAllOf
     */
    'approved'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoiceAllOf
     */
    'approvedBy'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoiceAllOf
     */
    'approvedByClientId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ReceivableInvoiceAllOf
     */
    'approvedImageUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ReceivableInvoiceAllOf
     */
    'documentSerial'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ReceivableInvoiceAllOf
     */
    'remarks'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ReceivableInvoiceAllOf
     */
    'name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoiceAllOf
     */
    'value'?: number;
    /**
     * 
     * @type {string}
     * @memberof ReceivableInvoiceAllOf
     */
    'dueDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ReceivableInvoiceAllOf
     */
    'expectedDate'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoiceAllOf
     */
    'createdBy'?: number;
    /**
     * 
     * @type {string}
     * @memberof ReceivableInvoiceAllOf
     */
    'documentId'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ReceivableInvoiceAllOf
     */
    'isDelete'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoiceAllOf
     */
    'vatRate'?: number;
    /**
     * 
     * @type {string}
     * @memberof ReceivableInvoiceAllOf
     */
    'internalNotes'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoiceAllOf
     */
    'galleryId'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ReceivableInvoiceAllOf
     */
    'isVatInclusive'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoiceAllOf
     */
    'salesId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ReceivableInvoiceAllOf
     */
    'salesName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoiceAllOf
     */
    'roundingAdjustment'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ReceivableInvoiceAllOf
     */
    'isInlineDiscount'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ReceivableInvoiceAllOf
     */
    'isInlineVat'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoiceAllOf
     */
    'tax'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoiceAllOf
     */
    'documentSerialNoPrefix'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoiceAllOf
     */
    'vatValue'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoiceAllOf
     */
    'resetTransactionId'?: number | null;
    /**
     * 
     * @type {Contact}
     * @memberof ReceivableInvoiceAllOf
     */
    'contact'?: Contact | null;
    /**
     * 
     * @type {User}
     * @memberof ReceivableInvoiceAllOf
     */
    'approvedByClient'?: User | null;
    /**
     * 
     * @type {Company}
     * @memberof ReceivableInvoiceAllOf
     */
    'company'?: Company | null;
    /**
     * 
     * @type {User}
     * @memberof ReceivableInvoiceAllOf
     */
    'createdByUser'?: User | null;
    /**
     * 
     * @type {User}
     * @memberof ReceivableInvoiceAllOf
     */
    'approvedByUser'?: User | null;
    /**
     * 
     * @type {User}
     * @memberof ReceivableInvoiceAllOf
     */
    'sales'?: User | null;
    /**
     * 
     * @type {Gallery}
     * @memberof ReceivableInvoiceAllOf
     */
    'gallery'?: Gallery | null;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoiceAllOf
     */
    'inlineVatValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoiceAllOf
     */
    'inlineDiscountValue'?: number;
    /**
     * 
     * @type {RuleCompileStatus}
     * @memberof ReceivableInvoiceAllOf
     */
    'ruleCompileStatus'?: RuleCompileStatus;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoiceAllOf
     */
    'runningNumberType'?: number;
    /**
     * 
     * @type {string}
     * @memberof ReceivableInvoiceAllOf
     */
    'runningModifiedOn'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoiceAllOf
     */
    'exemptAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoiceAllOf
     */
    'vatableAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoiceAllOf
     */
    'totalAfterDiscount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoiceAllOf
     */
    'subTotal'?: number;
    /**
     * 
     * @type {Array<IDocumentReference>}
     * @memberof ReceivableInvoiceAllOf
     */
    'documentReferences'?: Array<IDocumentReference> | null;
    /**
     * 
     * @type {Array<IDocumentReference>}
     * @memberof ReceivableInvoiceAllOf
     */
    'referencedToMe'?: Array<IDocumentReference> | null;
    /**
     * 
     * @type {Array<IDocumentReference>}
     * @memberof ReceivableInvoiceAllOf
     */
    'referencedByMe'?: Array<IDocumentReference> | null;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoiceAllOf
     */
    'statusInt'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ReceivableInvoiceAllOf
     */
    'isReCalculate'?: boolean;
    /**
     * 
     * @type {PartialPaymentMethod}
     * @memberof ReceivableInvoiceAllOf
     */
    'partialPaymentMethod'?: PartialPaymentMethod | null;
    /**
     * 
     * @type {number}
     * @memberof ReceivableInvoiceAllOf
     */
    'vatAmount'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ReceivableInvoiceAllOf
     */
    'isMigrate'?: boolean;
}
/**
 * 1 = Awaiting 3 = Approved 5 = ApprovedAndProcessed 7 = Void 9 = Delete
 * @export
 * @enum {string}
 */

export const ReceivableInvoiceStatus = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7,
    NUMBER_9: 9
} as const;

export type ReceivableInvoiceStatus = typeof ReceivableInvoiceStatus[keyof typeof ReceivableInvoiceStatus];


/**
 * 
 * @export
 * @interface ReconciledDocument
 */
export interface ReconciledDocument {
    /**
     * 
     * @type {number}
     * @memberof ReconciledDocument
     */
    'documentId'?: number;
    /**
     * 
     * @type {DocumentTypes}
     * @memberof ReconciledDocument
     */
    'documentType'?: DocumentTypes;
    /**
     * 
     * @type {string}
     * @memberof ReconciledDocument
     */
    'transactionId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ReconciledDocument
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ReconciledDocument
     */
    'fromAccount'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ReconciledDocument
     */
    'channel'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ReconciledDocument
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ReconciledDocument
     */
    'accountNumber': string;
    /**
     * 
     * @type {number}
     * @memberof ReconciledDocument
     */
    'bankId'?: number;
    /**
     * 
     * @type {number}
     * @memberof ReconciledDocument
     */
    'companyId'?: number;
    /**
     * 
     * @type {Bank}
     * @memberof ReconciledDocument
     */
    'bank'?: Bank | null;
    /**
     * 
     * @type {Company}
     * @memberof ReconciledDocument
     */
    'company'?: Company | null;
}
/**
 * 1 = CashShortOrOver 3 = CashDiscount 5 = ExchangeRateDiff 51 = SalesCashShortOrOver 53 = SalesDiscount 55 = SalesBankFee 57 = SalesExchangeRateDiff
 * @export
 * @enum {string}
 */

export const RemainingCollectedType = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_51: 51,
    NUMBER_53: 53,
    NUMBER_55: 55,
    NUMBER_57: 57
} as const;

export type RemainingCollectedType = typeof RemainingCollectedType[keyof typeof RemainingCollectedType];


/**
 * 10 = Sales 11 = SalesTeamReport 12 = SalesTax 13 = SimpleSales 14 = AccountReceivable 15 = AccountReceivableAging 20 = Purchase 21 = PurchaseTax 22 = AccountPayable 23 = AccountPayableAging 24 = PurchaseByProduct 25 = PurchaseByProductAdvance 30 = Clients 40 = Vendor 50 = PaymentCollection 60 = SalesByProduct 61 = SalesByProductAdvance 62 = SalesByPerson 63 = SalesByPersonAdvance 64 = SalesByCustomer 65 = SalesByCustomerAdvance 70 = Quotation 80 = BillingNote 90 = ReceiveInventory 91 = StocksReport 92 = GroupStockReport 100 = Expense 110 = WithHoldingTax 120 = ProfitAndLossOneMonth 121 = ProfitAndLossMultipleMonth 130 = Receipt 140 = CreditNote 150 = DebitNote 160 = TaxInvoice 170 = Payroll 171 = PayrollSummary 172 = PayrollGroup 173 = PayrollSscSummary 180 = ContactGrid 190 = ProductGrid 200 = ExportContact 210 = ExportProduct 220 = Receivables 240 = Payables 260 = GeneralLedger 270 = JournalEntry 280 = Payment 290 = InputTax 291 = OutputTax 292 = FixedAsset 293 = Depreciation 300 = PaymentSlip
 * @export
 * @enum {string}
 */

export const ReportTypes = {
    NUMBER_10: 10,
    NUMBER_11: 11,
    NUMBER_12: 12,
    NUMBER_13: 13,
    NUMBER_14: 14,
    NUMBER_15: 15,
    NUMBER_20: 20,
    NUMBER_21: 21,
    NUMBER_22: 22,
    NUMBER_23: 23,
    NUMBER_24: 24,
    NUMBER_25: 25,
    NUMBER_30: 30,
    NUMBER_40: 40,
    NUMBER_50: 50,
    NUMBER_60: 60,
    NUMBER_61: 61,
    NUMBER_62: 62,
    NUMBER_63: 63,
    NUMBER_64: 64,
    NUMBER_65: 65,
    NUMBER_70: 70,
    NUMBER_80: 80,
    NUMBER_90: 90,
    NUMBER_91: 91,
    NUMBER_92: 92,
    NUMBER_100: 100,
    NUMBER_110: 110,
    NUMBER_120: 120,
    NUMBER_121: 121,
    NUMBER_130: 130,
    NUMBER_140: 140,
    NUMBER_150: 150,
    NUMBER_160: 160,
    NUMBER_170: 170,
    NUMBER_171: 171,
    NUMBER_172: 172,
    NUMBER_173: 173,
    NUMBER_180: 180,
    NUMBER_190: 190,
    NUMBER_200: 200,
    NUMBER_210: 210,
    NUMBER_220: 220,
    NUMBER_240: 240,
    NUMBER_260: 260,
    NUMBER_270: 270,
    NUMBER_280: 280,
    NUMBER_290: 290,
    NUMBER_291: 291,
    NUMBER_292: 292,
    NUMBER_293: 293,
    NUMBER_300: 300
} as const;

export type ReportTypes = typeof ReportTypes[keyof typeof ReportTypes];


/**
 * 1 = Pending 3 = Execute 5 = Success 7 = Error 9 = WHTWarning 11 = NoMoreCompile 13 = Ignore
 * @export
 * @enum {string}
 */

export const RuleCompileStatus = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7,
    NUMBER_9: 9,
    NUMBER_11: 11,
    NUMBER_13: 13
} as const;

export type RuleCompileStatus = typeof RuleCompileStatus[keyof typeof RuleCompileStatus];


/**
 * 1 = Default 3 = YearMonth 5 = Month 7 = Year 9 = FreeHand
 * @export
 * @enum {string}
 */

export const RunningNumberType = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7,
    NUMBER_9: 9
} as const;

export type RunningNumberType = typeof RunningNumberType[keyof typeof RunningNumberType];


/**
 * 1 = Cash 3 = Credit 5 = Both
 * @export
 * @enum {string}
 */

export const SalesType = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5
} as const;

export type SalesType = typeof SalesType[keyof typeof SalesType];


/**
 * 1 = Sent 3 = NoEmail
 * @export
 * @enum {string}
 */

export const SendEmailStatus = {
    NUMBER_1: 1,
    NUMBER_3: 3
} as const;

export type SendEmailStatus = typeof SendEmailStatus[keyof typeof SendEmailStatus];


/**
 * 
 * @export
 * @interface SimpleDocument
 */
export interface SimpleDocument {
    /**
     * 
     * @type {number}
     * @memberof SimpleDocument
     */
    'recordId'?: number;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'contactCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'contactName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'contactAddress'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'contactTaxId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'contactBranch'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'contactPerson'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'contactEmail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'contactNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'contactZipCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SimpleDocument
     */
    'contactGroup'?: number;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'publishedOn'?: string;
    /**
     * 
     * @type {number}
     * @memberof SimpleDocument
     */
    'creditType'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimpleDocument
     */
    'creditDays'?: number;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'dueDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'salesName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'projectName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'reference'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SimpleDocument
     */
    'isVatInclusive'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SimpleDocument
     */
    'useReceiptDeduction'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof SimpleDocument
     */
    'subTotal'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimpleDocument
     */
    'discountPercentage'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimpleDocument
     */
    'discountAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimpleDocument
     */
    'totalAfterDiscount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SimpleDocument
     */
    'isVat'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof SimpleDocument
     */
    'vatAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimpleDocument
     */
    'grandTotal'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SimpleDocument
     */
    'documentShowWithholdingTax'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof SimpleDocument
     */
    'documentWithholdingTaxPercentage'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimpleDocument
     */
    'documentWithholdingTaxAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimpleDocument
     */
    'documentDeductionType'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimpleDocument
     */
    'documentDeductionAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'remarks'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'internalNotes'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SimpleDocument
     */
    'showSignatureOrStamp'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'documentStructureType'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'externalId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'saleAndPurchaseChannel'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'rowIndex'?: string | null;
    /**
     * 
     * @type {Array<SimpleProductItem>}
     * @memberof SimpleDocument
     */
    'items'?: Array<SimpleProductItem> | null;
    /**
     * 
     * @type {Array<UpgradeDocument>}
     * @memberof SimpleDocument
     */
    'documentReference'?: Array<UpgradeDocument> | null;
    /**
     * 
     * @type {number}
     * @memberof SimpleDocument
     */
    'exemptAmount'?: number | null;
}
/**
 * 
 * @export
 * @interface SimpleDocumentAllOf
 */
export interface SimpleDocumentAllOf {
    /**
     * 
     * @type {Array<SimpleProductItem>}
     * @memberof SimpleDocumentAllOf
     */
    'items'?: Array<SimpleProductItem> | null;
    /**
     * 
     * @type {Array<UpgradeDocument>}
     * @memberof SimpleDocumentAllOf
     */
    'documentReference'?: Array<UpgradeDocument> | null;
    /**
     * 
     * @type {number}
     * @memberof SimpleDocumentAllOf
     */
    'exemptAmount'?: number | null;
}
/**
 * 
 * @export
 * @interface SimpleProductItem
 */
export interface SimpleProductItem {
    /**
     * 
     * @type {number}
     * @memberof SimpleProductItem
     */
    'type'?: number;
    /**
     * 
     * @type {string}
     * @memberof SimpleProductItem
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleProductItem
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SimpleProductItem
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof SimpleProductItem
     */
    'unitName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SimpleProductItem
     */
    'pricePerUnit'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimpleProductItem
     */
    'total'?: number;
    /**
     * 
     * @type {string}
     * @memberof SimpleProductItem
     */
    'sellChartOfAccountCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleProductItem
     */
    'buyChartOfAccountCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleProductItem
     */
    'productCode'?: string | null;
}
/**
 * 
 * @export
 * @interface SimpleQuery
 */
export interface SimpleQuery {
    /**
     * 
     * @type {number}
     * @memberof SimpleQuery
     */
    'pageSize'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SimpleQuery
     */
    'currentPage'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SimpleQuery
     */
    'totalRecords'?: number;
    /**
     * 
     * @type {DateType}
     * @memberof SimpleQuery
     */
    'dateType'?: DateType;
    /**
     * 
     * @type {string}
     * @memberof SimpleQuery
     */
    'startDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleQuery
     */
    'endDate'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SimpleQuery
     */
    'day'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimpleQuery
     */
    'month'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimpleQuery
     */
    'year'?: number;
    /**
     * 
     * @type {DataRange}
     * @memberof SimpleQuery
     */
    'range'?: DataRange;
    /**
     * 
     * @type {number}
     * @memberof SimpleQuery
     */
    'isFirstCurrent'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof SimpleQuery
     */
    'hashTags'?: Array<string> | null;
    /**
     * 
     * @type {ReportTypes}
     * @memberof SimpleQuery
     */
    'reportType'?: ReportTypes;
    /**
     * 
     * @type {Array<FilterOptions>}
     * @memberof SimpleQuery
     */
    'filter'?: Array<FilterOptions> | null;
    /**
     * 
     * @type {Array<SortOptions>}
     * @memberof SimpleQuery
     */
    'sortBy'?: Array<SortOptions> | null;
}
/**
 * 
 * @export
 * @interface SortOptions
 */
export interface SortOptions {
    /**
     * 
     * @type {string}
     * @memberof SortOptions
     */
    'name'?: string | null;
    /**
     * 
     * @type {OrderBy}
     * @memberof SortOptions
     */
    'sortOrder'?: OrderBy;
}
/**
 * 
 * @export
 * @interface StockCard
 */
export interface StockCard {
    /**
     * 
     * @type {ObjectId}
     * @memberof StockCard
     */
    'id'?: ObjectId;
    /**
     * 
     * @type {number}
     * @memberof StockCard
     */
    'productId'?: number;
    /**
     * 
     * @type {string}
     * @memberof StockCard
     */
    'productName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StockCard
     */
    'productCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof StockCard
     */
    'inventoryId'?: number;
    /**
     * 
     * @type {InventoryType}
     * @memberof StockCard
     */
    'inventoryType'?: InventoryType;
    /**
     * 
     * @type {string}
     * @memberof StockCard
     */
    'date'?: string;
    /**
     * 
     * @type {number}
     * @memberof StockCard
     */
    'quantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof StockCard
     */
    'unitId'?: number;
    /**
     * 
     * @type {number}
     * @memberof StockCard
     */
    'unitPrice'?: number;
    /**
     * 
     * @type {string}
     * @memberof StockCard
     */
    'unitName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof StockCard
     */
    'total'?: number;
    /**
     * 
     * @type {number}
     * @memberof StockCard
     */
    'remaining'?: number;
    /**
     * 
     * @type {number}
     * @memberof StockCard
     */
    'documentId'?: number;
    /**
     * 
     * @type {DocumentTypes}
     * @memberof StockCard
     */
    'documentType'?: DocumentTypes;
    /**
     * 
     * @type {string}
     * @memberof StockCard
     */
    'documentSerial'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof StockCard
     */
    'allowDelete'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StockCard
     */
    'remarks'?: string | null;
    /**
     * 
     * @type {AdjustInventoryReason}
     * @memberof StockCard
     */
    'reason'?: AdjustInventoryReason;
    /**
     * 
     * @type {string}
     * @memberof StockCard
     */
    'contactName'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof StockCard
     */
    'isOverSold'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof StockCard
     */
    'rowIndex'?: number;
    /**
     * 
     * @type {string}
     * @memberof StockCard
     */
    'reasonDescription'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof StockCard
     */
    'averagePricePerUnit'?: number;
    /**
     * 
     * @type {number}
     * @memberof StockCard
     */
    'remainingAmount'?: number;
    /**
     * 
     * @type {Array<IStockCard>}
     * @memberof StockCard
     */
    'transactions'?: Array<IStockCard> | null;
}
/**
 * 
 * @export
 * @interface SupplierInvoice
 */
export interface SupplierInvoice {
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoice
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoice
     */
    'companyId': number;
    /**
     * 
     * @type {string}
     * @memberof SupplierInvoice
     */
    'documentDate': string;
    /**
     * 
     * @type {string}
     * @memberof SupplierInvoice
     */
    'documentSerial'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SupplierInvoice
     */
    'contactName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SupplierInvoice
     */
    'contactTaxId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SupplierInvoice
     */
    'contactBranch'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierInvoice
     */
    'isDelete'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoice
     */
    'galleryId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoice
     */
    'referenceDocumentId'?: number;
    /**
     * 
     * @type {DocumentTypes}
     * @memberof SupplierInvoice
     */
    'referenceDocumentType'?: DocumentTypes;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoice
     */
    'createdBy'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoice
     */
    'modifiedBy'?: number;
    /**
     * 
     * @type {string}
     * @memberof SupplierInvoice
     */
    'createdOn': string;
    /**
     * 
     * @type {string}
     * @memberof SupplierInvoice
     */
    'modifiedOn': string;
    /**
     * 
     * @type {Company}
     * @memberof SupplierInvoice
     */
    'company'?: Company | null;
    /**
     * 
     * @type {User}
     * @memberof SupplierInvoice
     */
    'createdByUser'?: User | null;
    /**
     * 
     * @type {User}
     * @memberof SupplierInvoice
     */
    'modifiedByUser'?: User | null;
    /**
     * 
     * @type {Gallery}
     * @memberof SupplierInvoice
     */
    'gallery'?: Gallery | null;
}
/**
 * 0 = None 1 = Awaiting 3 = WaitingForRefund 5 = CreatedBatchFilling 7 = NoRefund
 * @export
 * @enum {string}
 */

export const SupplierInvoiceStatus = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7
} as const;

export type SupplierInvoiceStatus = typeof SupplierInvoiceStatus[keyof typeof SupplierInvoiceStatus];


/**
 * 
 * @export
 * @interface SystemChartOfAccount
 */
export interface SystemChartOfAccount {
    /**
     * 
     * @type {number}
     * @memberof SystemChartOfAccount
     */
    'chartOfAccountId'?: number;
    /**
     * 
     * @type {number}
     * @memberof SystemChartOfAccount
     */
    'companyId': number;
    /**
     * 
     * @type {number}
     * @memberof SystemChartOfAccount
     */
    'systemCode': number;
    /**
     * 
     * @type {ChartOfAccount}
     * @memberof SystemChartOfAccount
     */
    'chartOfAccount'?: ChartOfAccount | null;
    /**
     * 
     * @type {number}
     * @memberof SystemChartOfAccount
     */
    'chartOfAccountIdCredit'?: number | null;
}
/**
 * 1 = ChatThai 3 = Rsu
 * @export
 * @enum {string}
 */

export const TemplateFont = {
    NUMBER_1: 1,
    NUMBER_3: 3
} as const;

export type TemplateFont = typeof TemplateFont[keyof typeof TemplateFont];


/**
 * 
 * @export
 * @interface UpgradeDocument
 */
export interface UpgradeDocument {
    /**
     * 
     * @type {number}
     * @memberof UpgradeDocument
     */
    'recordId'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpgradeDocument
     */
    'referenceDocumentSerial'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UpgradeDocument
     */
    'referenceDocumentType'?: number;
}
/**
 * 1 = Upgrade 3 = Renew 5 = ChangePackage
 * @export
 * @enum {string}
 */

export const UpgradeType = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5
} as const;

export type UpgradeType = typeof UpgradeType[keyof typeof UpgradeType];


/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'firstname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdon'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'phoneNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'mobile'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'referralCode'?: string | null;
}
/**
 * 1 = Include 3 = Exclude 5 = Zero 7 = None
 * @export
 * @enum {string}
 */

export const VatTypes = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7
} as const;

export type VatTypes = typeof VatTypes[keyof typeof VatTypes];



/**
 * BatchImportApi - axios parameter creator
 * @export
 */
export const BatchImportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete custom template
         * @param {string} templateId 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchImportDeleteCustomTemplate: async (templateId: string, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('batchImportDeleteCustomTemplate', 'templateId', templateId)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('batchImportDeleteCustomTemplate', 'culture', culture)
            const localVarPath = `/{culture}/cash-invoices/custom-template/{templateId}`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To get details of a document
         * @param {string} culture 
         * @param {string} [fileName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchImportGenerateBacthIdMetadata: async (culture: string, fileName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('batchImportGenerateBacthIdMetadata', 'culture', culture)
            const localVarPath = `/{culture}/cash-invoices/batch-metadata`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fileName !== undefined) {
                localVarQueryParameter['fileName'] = fileName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get data from Storage
         * @param {string} batchId 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchImportGetBatchS3Data: async (batchId: string, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('batchImportGetBatchS3Data', 'batchId', batchId)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('batchImportGetBatchS3Data', 'culture', culture)
            const localVarPath = `/{culture}/cash-invoices/get-batch-s3-data/{batchId}`
                .replace(`{${"batchId"}}`, encodeURIComponent(String(batchId)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get custom template
         * @param {string} templateId 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchImportGetCustomTemplate: async (templateId: string, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('batchImportGetCustomTemplate', 'templateId', templateId)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('batchImportGetCustomTemplate', 'culture', culture)
            const localVarPath = `/{culture}/cash-invoices/custom-template/{templateId}`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Original File
         * @param {string} batchId 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchImportGetOrgingalFile: async (batchId: string, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('batchImportGetOrgingalFile', 'batchId', batchId)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('batchImportGetOrgingalFile', 'culture', culture)
            const localVarPath = `/{culture}/cash-invoices/get-batch-import-org-file/{batchId}`
                .replace(`{${"batchId"}}`, encodeURIComponent(String(batchId)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get presign url to upload the file with payloads
         * @param {string} culture 
         * @param {BatchImportPayload} batchImportPayload 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchImportGetPresign: async (culture: string, batchImportPayload: BatchImportPayload, id?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('batchImportGetPresign', 'culture', culture)
            // verify required parameter 'batchImportPayload' is not null or undefined
            assertParamExists('batchImportGetPresign', 'batchImportPayload', batchImportPayload)
            const localVarPath = `/{culture}/cash-invoices/get-presign-for-upload-simpledoc`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchImportPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark the batch as viewed in notification.
         * @param {string} culture 
         * @param {number} body 
         * @param {number} [userId] 
         * @param {string} [batchId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchImportMarkViewed: async (culture: string, body: number, userId?: number, batchId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('batchImportMarkViewed', 'culture', culture)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('batchImportMarkViewed', 'body', body)
            const localVarPath = `/{culture}/cash-invoices/mark-viewed`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (batchId !== undefined) {
                localVarQueryParameter['batchId'] = batchId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query the batch by id and status
         * @param {string} culture 
         * @param {string} body 
         * @param {BatchImportStatus} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchImportQueryBatch: async (culture: string, body: string, status?: BatchImportStatus, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('batchImportQueryBatch', 'culture', culture)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('batchImportQueryBatch', 'body', body)
            const localVarPath = `/{culture}/cash-invoices/query-batch`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchImportQueryBatchHistory: async (culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('batchImportQueryBatchHistory', 'culture', culture)
            const localVarPath = `/{culture}/cash-invoices/batch-import-history`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} culture 
         * @param {BatchImportRetry} batchImportRetry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchImportRetrySimpleDocuments: async (culture: string, batchImportRetry: BatchImportRetry, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('batchImportRetrySimpleDocuments', 'culture', culture)
            // verify required parameter 'batchImportRetry' is not null or undefined
            assertParamExists('batchImportRetrySimpleDocuments', 'batchImportRetry', batchImportRetry)
            const localVarPath = `/{culture}/cash-invoices/retry-simple-documents`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchImportRetry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create or Update (Upsert) custom template
         * @param {string} culture 
         * @param {CustomTemplate} customTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchImportUpsertCustomTemplate: async (culture: string, customTemplate: CustomTemplate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('batchImportUpsertCustomTemplate', 'culture', culture)
            // verify required parameter 'customTemplate' is not null or undefined
            assertParamExists('batchImportUpsertCustomTemplate', 'customTemplate', customTemplate)
            const localVarPath = `/{culture}/cash-invoices/custom-template`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BatchImportApi - functional programming interface
 * @export
 */
export const BatchImportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BatchImportApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete custom template
         * @param {string} templateId 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchImportDeleteCustomTemplate(templateId: string, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchImportDeleteCustomTemplate(templateId, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To get details of a document
         * @param {string} culture 
         * @param {string} [fileName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchImportGenerateBacthIdMetadata(culture: string, fileName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchImportMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchImportGenerateBacthIdMetadata(culture, fileName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get data from Storage
         * @param {string} batchId 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchImportGetBatchS3Data(batchId: string, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchImportGetBatchS3Data(batchId, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get custom template
         * @param {string} templateId 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchImportGetCustomTemplate(templateId: string, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchImportGetCustomTemplate(templateId, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Original File
         * @param {string} batchId 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchImportGetOrgingalFile(batchId: string, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchImportGetOrgingalFile(batchId, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get presign url to upload the file with payloads
         * @param {string} culture 
         * @param {BatchImportPayload} batchImportPayload 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchImportGetPresign(culture: string, batchImportPayload: BatchImportPayload, id?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchImportGetPresign(culture, batchImportPayload, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Mark the batch as viewed in notification.
         * @param {string} culture 
         * @param {number} body 
         * @param {number} [userId] 
         * @param {string} [batchId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchImportMarkViewed(culture: string, body: number, userId?: number, batchId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchImportMarkViewed(culture, body, userId, batchId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Query the batch by id and status
         * @param {string} culture 
         * @param {string} body 
         * @param {BatchImportStatus} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchImportQueryBatch(culture: string, body: string, status?: BatchImportStatus, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchImportQueryBatch(culture, body, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchImportQueryBatchHistory(culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchImportQueryBatchHistory(culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} culture 
         * @param {BatchImportRetry} batchImportRetry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchImportRetrySimpleDocuments(culture: string, batchImportRetry: BatchImportRetry, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchImportRetrySimpleDocuments(culture, batchImportRetry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create or Update (Upsert) custom template
         * @param {string} culture 
         * @param {CustomTemplate} customTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchImportUpsertCustomTemplate(culture: string, customTemplate: CustomTemplate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchImportUpsertCustomTemplate(culture, customTemplate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BatchImportApi - factory interface
 * @export
 */
export const BatchImportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BatchImportApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete custom template
         * @param {string} templateId 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchImportDeleteCustomTemplate(templateId: string, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.batchImportDeleteCustomTemplate(templateId, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To get details of a document
         * @param {string} culture 
         * @param {string} [fileName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchImportGenerateBacthIdMetadata(culture: string, fileName?: string, options?: any): AxiosPromise<BatchImportMetadata> {
            return localVarFp.batchImportGenerateBacthIdMetadata(culture, fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get data from Storage
         * @param {string} batchId 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchImportGetBatchS3Data(batchId: string, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.batchImportGetBatchS3Data(batchId, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get custom template
         * @param {string} templateId 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchImportGetCustomTemplate(templateId: string, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.batchImportGetCustomTemplate(templateId, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Original File
         * @param {string} batchId 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchImportGetOrgingalFile(batchId: string, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.batchImportGetOrgingalFile(batchId, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get presign url to upload the file with payloads
         * @param {string} culture 
         * @param {BatchImportPayload} batchImportPayload 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchImportGetPresign(culture: string, batchImportPayload: BatchImportPayload, id?: number, options?: any): AxiosPromise<any> {
            return localVarFp.batchImportGetPresign(culture, batchImportPayload, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mark the batch as viewed in notification.
         * @param {string} culture 
         * @param {number} body 
         * @param {number} [userId] 
         * @param {string} [batchId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchImportMarkViewed(culture: string, body: number, userId?: number, batchId?: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.batchImportMarkViewed(culture, body, userId, batchId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query the batch by id and status
         * @param {string} culture 
         * @param {string} body 
         * @param {BatchImportStatus} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchImportQueryBatch(culture: string, body: string, status?: BatchImportStatus, options?: any): AxiosPromise<BatchStatus> {
            return localVarFp.batchImportQueryBatch(culture, body, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchImportQueryBatchHistory(culture: string, options?: any): AxiosPromise<BatchHistory> {
            return localVarFp.batchImportQueryBatchHistory(culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} culture 
         * @param {BatchImportRetry} batchImportRetry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchImportRetrySimpleDocuments(culture: string, batchImportRetry: BatchImportRetry, options?: any): AxiosPromise<boolean> {
            return localVarFp.batchImportRetrySimpleDocuments(culture, batchImportRetry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create or Update (Upsert) custom template
         * @param {string} culture 
         * @param {CustomTemplate} customTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchImportUpsertCustomTemplate(culture: string, customTemplate: CustomTemplate, options?: any): AxiosPromise<any> {
            return localVarFp.batchImportUpsertCustomTemplate(culture, customTemplate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BatchImportApi - object-oriented interface
 * @export
 * @class BatchImportApi
 * @extends {BaseAPI}
 */
export class BatchImportApi extends BaseAPI {
    /**
     * 
     * @summary Delete custom template
     * @param {string} templateId 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchImportApi
     */
    public batchImportDeleteCustomTemplate(templateId: string, culture: string, options?: AxiosRequestConfig) {
        return BatchImportApiFp(this.configuration).batchImportDeleteCustomTemplate(templateId, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To get details of a document
     * @param {string} culture 
     * @param {string} [fileName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchImportApi
     */
    public batchImportGenerateBacthIdMetadata(culture: string, fileName?: string, options?: AxiosRequestConfig) {
        return BatchImportApiFp(this.configuration).batchImportGenerateBacthIdMetadata(culture, fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get data from Storage
     * @param {string} batchId 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchImportApi
     */
    public batchImportGetBatchS3Data(batchId: string, culture: string, options?: AxiosRequestConfig) {
        return BatchImportApiFp(this.configuration).batchImportGetBatchS3Data(batchId, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get custom template
     * @param {string} templateId 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchImportApi
     */
    public batchImportGetCustomTemplate(templateId: string, culture: string, options?: AxiosRequestConfig) {
        return BatchImportApiFp(this.configuration).batchImportGetCustomTemplate(templateId, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Original File
     * @param {string} batchId 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchImportApi
     */
    public batchImportGetOrgingalFile(batchId: string, culture: string, options?: AxiosRequestConfig) {
        return BatchImportApiFp(this.configuration).batchImportGetOrgingalFile(batchId, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get presign url to upload the file with payloads
     * @param {string} culture 
     * @param {BatchImportPayload} batchImportPayload 
     * @param {number} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchImportApi
     */
    public batchImportGetPresign(culture: string, batchImportPayload: BatchImportPayload, id?: number, options?: AxiosRequestConfig) {
        return BatchImportApiFp(this.configuration).batchImportGetPresign(culture, batchImportPayload, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mark the batch as viewed in notification.
     * @param {string} culture 
     * @param {number} body 
     * @param {number} [userId] 
     * @param {string} [batchId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchImportApi
     */
    public batchImportMarkViewed(culture: string, body: number, userId?: number, batchId?: string, options?: AxiosRequestConfig) {
        return BatchImportApiFp(this.configuration).batchImportMarkViewed(culture, body, userId, batchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query the batch by id and status
     * @param {string} culture 
     * @param {string} body 
     * @param {BatchImportStatus} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchImportApi
     */
    public batchImportQueryBatch(culture: string, body: string, status?: BatchImportStatus, options?: AxiosRequestConfig) {
        return BatchImportApiFp(this.configuration).batchImportQueryBatch(culture, body, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchImportApi
     */
    public batchImportQueryBatchHistory(culture: string, options?: AxiosRequestConfig) {
        return BatchImportApiFp(this.configuration).batchImportQueryBatchHistory(culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} culture 
     * @param {BatchImportRetry} batchImportRetry 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchImportApi
     */
    public batchImportRetrySimpleDocuments(culture: string, batchImportRetry: BatchImportRetry, options?: AxiosRequestConfig) {
        return BatchImportApiFp(this.configuration).batchImportRetrySimpleDocuments(culture, batchImportRetry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create or Update (Upsert) custom template
     * @param {string} culture 
     * @param {CustomTemplate} customTemplate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchImportApi
     */
    public batchImportUpsertCustomTemplate(culture: string, customTemplate: CustomTemplate, options?: AxiosRequestConfig) {
        return BatchImportApiFp(this.configuration).batchImportUpsertCustomTemplate(culture, customTemplate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BillingNoteApi - axios parameter creator
 * @export
 */
export const BillingNoteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingNoteChangeStatusByKey: async (documentId: number, statusKey: string, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('billingNoteChangeStatusByKey', 'documentId', documentId)
            // verify required parameter 'statusKey' is not null or undefined
            assertParamExists('billingNoteChangeStatusByKey', 'statusKey', statusKey)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('billingNoteChangeStatusByKey', 'culture', culture)
            const localVarPath = `/{culture}/billing-notes/{documentId}/status-key/{statusKey}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"statusKey"}}`, encodeURIComponent(String(statusKey)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingNoteCreate: async (culture: string, simpleDocument: SimpleDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('billingNoteCreate', 'culture', culture)
            // verify required parameter 'simpleDocument' is not null or undefined
            assertParamExists('billingNoteCreate', 'simpleDocument', simpleDocument)
            const localVarPath = `/{culture}/billing-notes/simple-document`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(simpleDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingNoteCreate2: async (culture: string, inlineDocument: InlineDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('billingNoteCreate2', 'culture', culture)
            // verify required parameter 'inlineDocument' is not null or undefined
            assertParamExists('billingNoteCreate2', 'inlineDocument', inlineDocument)
            const localVarPath = `/{culture}/billing-notes/inline-document`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingNoteDelete: async (id: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('billingNoteDelete', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('billingNoteDelete', 'culture', culture)
            const localVarPath = `/{culture}/billing-notes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingNoteDetails: async (id: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('billingNoteDetails', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('billingNoteDetails', 'culture', culture)
            const localVarPath = `/{culture}/billing-notes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingNoteEdit: async (id: number, culture: string, simpleDocument: SimpleDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('billingNoteEdit', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('billingNoteEdit', 'culture', culture)
            // verify required parameter 'simpleDocument' is not null or undefined
            assertParamExists('billingNoteEdit', 'simpleDocument', simpleDocument)
            const localVarPath = `/{culture}/billing-notes/simple-document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(simpleDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingNoteEdit2: async (id: number, culture: string, inlineDocument: InlineDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('billingNoteEdit2', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('billingNoteEdit2', 'culture', culture)
            // verify required parameter 'inlineDocument' is not null or undefined
            assertParamExists('billingNoteEdit2', 'inlineDocument', inlineDocument)
            const localVarPath = `/{culture}/billing-notes/inline-document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingNoteIndex: async (culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('billingNoteIndex', 'culture', culture)
            const localVarPath = `/{culture}/billing-notes`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sortBy !== undefined) {
                localVarQueryParameter['SortBy'] = sortBy;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['CurrentPage'] = currentPage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (filter !== undefined) {
                localVarQueryParameter['Filter'] = filter;
            }

            if (searchString !== undefined) {
                localVarQueryParameter['SearchString'] = searchString;
            }

            if (customDocumentModels !== undefined) {
                localVarQueryParameter['CustomDocumentModels'] = customDocumentModels;
            }

            if (range !== undefined) {
                localVarQueryParameter['Range'] = range;
            }

            if (month !== undefined) {
                localVarQueryParameter['Month'] = month;
            }

            if (year !== undefined) {
                localVarQueryParameter['Year'] = year;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['StartDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['EndDate'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingNoteReceivePayment: async (id: number, culture: string, paymentModel: PaymentModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('billingNoteReceivePayment', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('billingNoteReceivePayment', 'culture', culture)
            // verify required parameter 'paymentModel' is not null or undefined
            assertParamExists('billingNoteReceivePayment', 'paymentModel', paymentModel)
            const localVarPath = `/{culture}/billing-notes/{id}/payments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingNoteApi - functional programming interface
 * @export
 */
export const BillingNoteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingNoteApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingNoteChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingNoteChangeStatusByKey(documentId, statusKey, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingNoteCreate(culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageSent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingNoteCreate(culture, simpleDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingNoteCreate2(culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageSent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingNoteCreate2(culture, inlineDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingNoteDelete(id: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingNoteDelete(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingNoteDetails(id: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingNoteDetails(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingNoteEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingNoteEdit(id, culture, simpleDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingNoteEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingNoteEdit2(id, culture, inlineDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingNoteIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingNoteIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingNoteReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingNoteReceivePayment(id, culture, paymentModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BillingNoteApi - factory interface
 * @export
 */
export const BillingNoteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingNoteApiFp(configuration)
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingNoteChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.billingNoteChangeStatusByKey(documentId, statusKey, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingNoteCreate(culture: string, simpleDocument: SimpleDocument, options?: any): AxiosPromise<MessageSent> {
            return localVarFp.billingNoteCreate(culture, simpleDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingNoteCreate2(culture: string, inlineDocument: InlineDocument, options?: any): AxiosPromise<MessageSent> {
            return localVarFp.billingNoteCreate2(culture, inlineDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingNoteDelete(id: number, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.billingNoteDelete(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingNoteDetails(id: number, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.billingNoteDetails(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingNoteEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: any): AxiosPromise<any> {
            return localVarFp.billingNoteEdit(id, culture, simpleDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingNoteEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: any): AxiosPromise<any> {
            return localVarFp.billingNoteEdit2(id, culture, inlineDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingNoteIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: any): AxiosPromise<any> {
            return localVarFp.billingNoteIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingNoteReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: any): AxiosPromise<any> {
            return localVarFp.billingNoteReceivePayment(id, culture, paymentModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingNoteApi - object-oriented interface
 * @export
 * @class BillingNoteApi
 * @extends {BaseAPI}
 */
export class BillingNoteApi extends BaseAPI {
    /**
     * 
     * @summary To change status by the document id and key
     * @param {number} documentId 
     * @param {string} statusKey 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingNoteApi
     */
    public billingNoteChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: AxiosRequestConfig) {
        return BillingNoteApiFp(this.configuration).billingNoteChangeStatusByKey(documentId, statusKey, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Create a document with SimpleDocument as the parameter
     * @param {string} culture 
     * @param {SimpleDocument} simpleDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingNoteApi
     */
    public billingNoteCreate(culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig) {
        return BillingNoteApiFp(this.configuration).billingNoteCreate(culture, simpleDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Create a document with InlineDocument as the parameter
     * @param {string} culture 
     * @param {InlineDocument} inlineDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingNoteApi
     */
    public billingNoteCreate2(culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig) {
        return BillingNoteApiFp(this.configuration).billingNoteCreate2(culture, inlineDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To delete the document given a list of documentids
     * @param {number} id 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingNoteApi
     */
    public billingNoteDelete(id: number, culture: string, options?: AxiosRequestConfig) {
        return BillingNoteApiFp(this.configuration).billingNoteDelete(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To get details of a document
     * @param {number} id Sql DocumentId
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingNoteApi
     */
    public billingNoteDetails(id: number, culture: string, options?: AxiosRequestConfig) {
        return BillingNoteApiFp(this.configuration).billingNoteDetails(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Update a document with simpleDocument as the parameter
     * @param {number} id 
     * @param {string} culture 
     * @param {SimpleDocument} simpleDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingNoteApi
     */
    public billingNoteEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig) {
        return BillingNoteApiFp(this.configuration).billingNoteEdit(id, culture, simpleDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Update a document with inlineDocument as the parameter
     * @param {number} id 
     * @param {string} culture 
     * @param {InlineDocument} inlineDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingNoteApi
     */
    public billingNoteEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig) {
        return BillingNoteApiFp(this.configuration).billingNoteEdit2(id, culture, inlineDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To query for documents.
     * @param {string} culture 
     * @param {string} [sortBy] 
     * @param {string} [currentPage] 
     * @param {string} [pageSize] 
     * @param {string} [filter] 
     * @param {string} [searchString] 
     * @param {string} [customDocumentModels] 
     * @param {string} [range] 
     * @param {string} [month] 
     * @param {string} [year] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingNoteApi
     */
    public billingNoteIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: AxiosRequestConfig) {
        return BillingNoteApiFp(this.configuration).billingNoteIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Accept payment with the paymentModel
     * @param {number} id 
     * @param {string} culture 
     * @param {PaymentModel} paymentModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingNoteApi
     */
    public billingNoteReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: AxiosRequestConfig) {
        return BillingNoteApiFp(this.configuration).billingNoteReceivePayment(id, culture, paymentModel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CashInvoiceApi - axios parameter creator
 * @export
 */
export const CashInvoiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceChangeStatusByKey: async (documentId: number, statusKey: string, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('cashInvoiceChangeStatusByKey', 'documentId', documentId)
            // verify required parameter 'statusKey' is not null or undefined
            assertParamExists('cashInvoiceChangeStatusByKey', 'statusKey', statusKey)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('cashInvoiceChangeStatusByKey', 'culture', culture)
            const localVarPath = `/{culture}/cash-invoices/{documentId}/status-key/{statusKey}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"statusKey"}}`, encodeURIComponent(String(statusKey)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceCreate: async (culture: string, simpleDocument: SimpleDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('cashInvoiceCreate', 'culture', culture)
            // verify required parameter 'simpleDocument' is not null or undefined
            assertParamExists('cashInvoiceCreate', 'simpleDocument', simpleDocument)
            const localVarPath = `/{culture}/cash-invoices/simple-document`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(simpleDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceCreate2: async (culture: string, inlineDocument: InlineDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('cashInvoiceCreate2', 'culture', culture)
            // verify required parameter 'inlineDocument' is not null or undefined
            assertParamExists('cashInvoiceCreate2', 'inlineDocument', inlineDocument)
            const localVarPath = `/{culture}/cash-invoices/inline-document`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceDelete: async (id: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cashInvoiceDelete', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('cashInvoiceDelete', 'culture', culture)
            const localVarPath = `/{culture}/cash-invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceDetails: async (id: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cashInvoiceDetails', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('cashInvoiceDetails', 'culture', culture)
            const localVarPath = `/{culture}/cash-invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceEdit: async (id: number, culture: string, simpleDocument: SimpleDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cashInvoiceEdit', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('cashInvoiceEdit', 'culture', culture)
            // verify required parameter 'simpleDocument' is not null or undefined
            assertParamExists('cashInvoiceEdit', 'simpleDocument', simpleDocument)
            const localVarPath = `/{culture}/cash-invoices/simple-document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(simpleDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceEdit2: async (id: number, culture: string, inlineDocument: InlineDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cashInvoiceEdit2', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('cashInvoiceEdit2', 'culture', culture)
            // verify required parameter 'inlineDocument' is not null or undefined
            assertParamExists('cashInvoiceEdit2', 'inlineDocument', inlineDocument)
            const localVarPath = `/{culture}/cash-invoices/inline-document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceIndex: async (culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('cashInvoiceIndex', 'culture', culture)
            const localVarPath = `/{culture}/cash-invoices`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sortBy !== undefined) {
                localVarQueryParameter['SortBy'] = sortBy;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['CurrentPage'] = currentPage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (filter !== undefined) {
                localVarQueryParameter['Filter'] = filter;
            }

            if (searchString !== undefined) {
                localVarQueryParameter['SearchString'] = searchString;
            }

            if (customDocumentModels !== undefined) {
                localVarQueryParameter['CustomDocumentModels'] = customDocumentModels;
            }

            if (range !== undefined) {
                localVarQueryParameter['Range'] = range;
            }

            if (month !== undefined) {
                localVarQueryParameter['Month'] = month;
            }

            if (year !== undefined) {
                localVarQueryParameter['Year'] = year;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['StartDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['EndDate'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceReceivePayment: async (id: number, culture: string, paymentModel: PaymentModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cashInvoiceReceivePayment', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('cashInvoiceReceivePayment', 'culture', culture)
            // verify required parameter 'paymentModel' is not null or undefined
            assertParamExists('cashInvoiceReceivePayment', 'paymentModel', paymentModel)
            const localVarPath = `/{culture}/cash-invoices/{id}/payments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CashInvoiceApi - functional programming interface
 * @export
 */
export const CashInvoiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CashInvoiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cashInvoiceChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cashInvoiceChangeStatusByKey(documentId, statusKey, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cashInvoiceCreate(culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageSent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cashInvoiceCreate(culture, simpleDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cashInvoiceCreate2(culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageSent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cashInvoiceCreate2(culture, inlineDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cashInvoiceDelete(id: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cashInvoiceDelete(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cashInvoiceDetails(id: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cashInvoiceDetails(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cashInvoiceEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cashInvoiceEdit(id, culture, simpleDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cashInvoiceEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cashInvoiceEdit2(id, culture, inlineDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cashInvoiceIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cashInvoiceIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cashInvoiceReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cashInvoiceReceivePayment(id, culture, paymentModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CashInvoiceApi - factory interface
 * @export
 */
export const CashInvoiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CashInvoiceApiFp(configuration)
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.cashInvoiceChangeStatusByKey(documentId, statusKey, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceCreate(culture: string, simpleDocument: SimpleDocument, options?: any): AxiosPromise<MessageSent> {
            return localVarFp.cashInvoiceCreate(culture, simpleDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceCreate2(culture: string, inlineDocument: InlineDocument, options?: any): AxiosPromise<MessageSent> {
            return localVarFp.cashInvoiceCreate2(culture, inlineDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceDelete(id: number, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.cashInvoiceDelete(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceDetails(id: number, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.cashInvoiceDetails(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: any): AxiosPromise<any> {
            return localVarFp.cashInvoiceEdit(id, culture, simpleDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: any): AxiosPromise<any> {
            return localVarFp.cashInvoiceEdit2(id, culture, inlineDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: any): AxiosPromise<any> {
            return localVarFp.cashInvoiceIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: any): AxiosPromise<any> {
            return localVarFp.cashInvoiceReceivePayment(id, culture, paymentModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CashInvoiceApi - object-oriented interface
 * @export
 * @class CashInvoiceApi
 * @extends {BaseAPI}
 */
export class CashInvoiceApi extends BaseAPI {
    /**
     * 
     * @summary To change status by the document id and key
     * @param {number} documentId 
     * @param {string} statusKey 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashInvoiceApi
     */
    public cashInvoiceChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: AxiosRequestConfig) {
        return CashInvoiceApiFp(this.configuration).cashInvoiceChangeStatusByKey(documentId, statusKey, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Create a document with SimpleDocument as the parameter
     * @param {string} culture 
     * @param {SimpleDocument} simpleDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashInvoiceApi
     */
    public cashInvoiceCreate(culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig) {
        return CashInvoiceApiFp(this.configuration).cashInvoiceCreate(culture, simpleDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Create a document with InlineDocument as the parameter
     * @param {string} culture 
     * @param {InlineDocument} inlineDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashInvoiceApi
     */
    public cashInvoiceCreate2(culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig) {
        return CashInvoiceApiFp(this.configuration).cashInvoiceCreate2(culture, inlineDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To delete the document given a list of documentids
     * @param {number} id 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashInvoiceApi
     */
    public cashInvoiceDelete(id: number, culture: string, options?: AxiosRequestConfig) {
        return CashInvoiceApiFp(this.configuration).cashInvoiceDelete(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To get details of a document
     * @param {number} id Sql DocumentId
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashInvoiceApi
     */
    public cashInvoiceDetails(id: number, culture: string, options?: AxiosRequestConfig) {
        return CashInvoiceApiFp(this.configuration).cashInvoiceDetails(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Update a document with simpleDocument as the parameter
     * @param {number} id 
     * @param {string} culture 
     * @param {SimpleDocument} simpleDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashInvoiceApi
     */
    public cashInvoiceEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig) {
        return CashInvoiceApiFp(this.configuration).cashInvoiceEdit(id, culture, simpleDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Update a document with inlineDocument as the parameter
     * @param {number} id 
     * @param {string} culture 
     * @param {InlineDocument} inlineDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashInvoiceApi
     */
    public cashInvoiceEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig) {
        return CashInvoiceApiFp(this.configuration).cashInvoiceEdit2(id, culture, inlineDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To query for documents.
     * @param {string} culture 
     * @param {string} [sortBy] 
     * @param {string} [currentPage] 
     * @param {string} [pageSize] 
     * @param {string} [filter] 
     * @param {string} [searchString] 
     * @param {string} [customDocumentModels] 
     * @param {string} [range] 
     * @param {string} [month] 
     * @param {string} [year] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashInvoiceApi
     */
    public cashInvoiceIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: AxiosRequestConfig) {
        return CashInvoiceApiFp(this.configuration).cashInvoiceIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Accept payment with the paymentModel
     * @param {number} id 
     * @param {string} culture 
     * @param {PaymentModel} paymentModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashInvoiceApi
     */
    public cashInvoiceReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: AxiosRequestConfig) {
        return CashInvoiceApiFp(this.configuration).cashInvoiceReceivePayment(id, culture, paymentModel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CompanyCurrencyApi - axios parameter creator
 * @export
 */
export const CompanyCurrencyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get company currencies except selected list
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCurrencyGetCompanyCurrencies: async (culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('companyCurrencyGetCompanyCurrencies', 'culture', culture)
            const localVarPath = `/{culture}/company-currency/currency`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all currency which user selected for multi-currency
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCurrencyGetList: async (culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('companyCurrencyGetList', 'culture', culture)
            const localVarPath = `/{culture}/company-currency`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompanyCurrencyApi - functional programming interface
 * @export
 */
export const CompanyCurrencyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CompanyCurrencyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get company currencies except selected list
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyCurrencyGetCompanyCurrencies(culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyCurrencyGetCompanyCurrencies(culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all currency which user selected for multi-currency
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyCurrencyGetList(culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyCurrencyGetList(culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CompanyCurrencyApi - factory interface
 * @export
 */
export const CompanyCurrencyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CompanyCurrencyApiFp(configuration)
    return {
        /**
         * 
         * @summary Get company currencies except selected list
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCurrencyGetCompanyCurrencies(culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.companyCurrencyGetCompanyCurrencies(culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all currency which user selected for multi-currency
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCurrencyGetList(culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.companyCurrencyGetList(culture, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CompanyCurrencyApi - object-oriented interface
 * @export
 * @class CompanyCurrencyApi
 * @extends {BaseAPI}
 */
export class CompanyCurrencyApi extends BaseAPI {
    /**
     * 
     * @summary Get company currencies except selected list
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyCurrencyApi
     */
    public companyCurrencyGetCompanyCurrencies(culture: string, options?: AxiosRequestConfig) {
        return CompanyCurrencyApiFp(this.configuration).companyCurrencyGetCompanyCurrencies(culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all currency which user selected for multi-currency
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyCurrencyApi
     */
    public companyCurrencyGetList(culture: string, options?: AxiosRequestConfig) {
        return CompanyCurrencyApiFp(this.configuration).companyCurrencyGetList(culture, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContactApi - axios parameter creator
 * @export
 */
export const ContactApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} culture 
         * @param {ContactResult} contactResult 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactCreate: async (culture: string, contactResult: ContactResult, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('contactCreate', 'culture', culture)
            // verify required parameter 'contactResult' is not null or undefined
            assertParamExists('contactCreate', 'contactResult', contactResult)
            const localVarPath = `/api/{culture}/contacts`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactResult, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactGetContactList: async (id: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contactGetContactList', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('contactGetContactList', 'culture', culture)
            const localVarPath = `/api/{culture}/contacts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactGetContactList2: async (id: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contactGetContactList2', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('contactGetContactList2', 'culture', culture)
            const localVarPath = `/api/{culture}/contacts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactRemoveContact: async (id: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contactRemoveContact', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('contactRemoveContact', 'culture', culture)
            const localVarPath = `/api/{culture}/contacts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactSearch: async (culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('contactSearch', 'culture', culture)
            const localVarPath = `/api/{culture}/contacts/search`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {ContactResult} contactResult 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactUpdate: async (id: number, culture: string, contactResult: ContactResult, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contactUpdate', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('contactUpdate', 'culture', culture)
            // verify required parameter 'contactResult' is not null or undefined
            assertParamExists('contactUpdate', 'contactResult', contactResult)
            const localVarPath = `/api/{culture}/contacts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactResult, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} contactId 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactUploadContactQRCode: async (contactId: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('contactUploadContactQRCode', 'contactId', contactId)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('contactUploadContactQRCode', 'culture', culture)
            const localVarPath = `/api/{culture}/contacts/{contactId}/update-contact-qrcode`
                .replace(`{${"contactId"}}`, encodeURIComponent(String(contactId)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactApi - functional programming interface
 * @export
 */
export const ContactApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} culture 
         * @param {ContactResult} contactResult 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactCreate(culture: string, contactResult: ContactResult, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactCreate(culture, contactResult, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactGetContactList(id: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactGetContactList(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactGetContactList2(id: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactGetContactList2(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactRemoveContact(id: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactRemoveContact(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactSearch(culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactSearch(culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {ContactResult} contactResult 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactUpdate(id: number, culture: string, contactResult: ContactResult, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactUpdate(id, culture, contactResult, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} contactId 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactUploadContactQRCode(contactId: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactUploadContactQRCode(contactId, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContactApi - factory interface
 * @export
 */
export const ContactApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactApiFp(configuration)
    return {
        /**
         * 
         * @param {string} culture 
         * @param {ContactResult} contactResult 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactCreate(culture: string, contactResult: ContactResult, options?: any): AxiosPromise<any> {
            return localVarFp.contactCreate(culture, contactResult, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactGetContactList(id: number, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.contactGetContactList(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactGetContactList2(id: number, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.contactGetContactList2(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactRemoveContact(id: number, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.contactRemoveContact(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactSearch(culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.contactSearch(culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {ContactResult} contactResult 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactUpdate(id: number, culture: string, contactResult: ContactResult, options?: any): AxiosPromise<any> {
            return localVarFp.contactUpdate(id, culture, contactResult, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} contactId 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactUploadContactQRCode(contactId: number, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.contactUploadContactQRCode(contactId, culture, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContactApi - object-oriented interface
 * @export
 * @class ContactApi
 * @extends {BaseAPI}
 */
export class ContactApi extends BaseAPI {
    /**
     * 
     * @param {string} culture 
     * @param {ContactResult} contactResult 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public contactCreate(culture: string, contactResult: ContactResult, options?: AxiosRequestConfig) {
        return ContactApiFp(this.configuration).contactCreate(culture, contactResult, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public contactGetContactList(id: number, culture: string, options?: AxiosRequestConfig) {
        return ContactApiFp(this.configuration).contactGetContactList(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public contactGetContactList2(id: number, culture: string, options?: AxiosRequestConfig) {
        return ContactApiFp(this.configuration).contactGetContactList2(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public contactRemoveContact(id: number, culture: string, options?: AxiosRequestConfig) {
        return ContactApiFp(this.configuration).contactRemoveContact(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public contactSearch(culture: string, options?: AxiosRequestConfig) {
        return ContactApiFp(this.configuration).contactSearch(culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} culture 
     * @param {ContactResult} contactResult 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public contactUpdate(id: number, culture: string, contactResult: ContactResult, options?: AxiosRequestConfig) {
        return ContactApiFp(this.configuration).contactUpdate(id, culture, contactResult, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} contactId 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public contactUploadContactQRCode(contactId: number, culture: string, options?: AxiosRequestConfig) {
        return ContactApiFp(this.configuration).contactUploadContactQRCode(contactId, culture, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CreditNoteApi - axios parameter creator
 * @export
 */
export const CreditNoteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditNoteChangeStatusByKey: async (documentId: number, statusKey: string, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('creditNoteChangeStatusByKey', 'documentId', documentId)
            // verify required parameter 'statusKey' is not null or undefined
            assertParamExists('creditNoteChangeStatusByKey', 'statusKey', statusKey)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('creditNoteChangeStatusByKey', 'culture', culture)
            const localVarPath = `/{culture}/credit-notes/{documentId}/status-key/{statusKey}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"statusKey"}}`, encodeURIComponent(String(statusKey)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditNoteCreate: async (culture: string, simpleDocument: SimpleDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('creditNoteCreate', 'culture', culture)
            // verify required parameter 'simpleDocument' is not null or undefined
            assertParamExists('creditNoteCreate', 'simpleDocument', simpleDocument)
            const localVarPath = `/{culture}/credit-notes/simple-document`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(simpleDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditNoteCreate2: async (culture: string, inlineDocument: InlineDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('creditNoteCreate2', 'culture', culture)
            // verify required parameter 'inlineDocument' is not null or undefined
            assertParamExists('creditNoteCreate2', 'inlineDocument', inlineDocument)
            const localVarPath = `/{culture}/credit-notes/inline-document`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditNoteDelete: async (id: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('creditNoteDelete', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('creditNoteDelete', 'culture', culture)
            const localVarPath = `/{culture}/credit-notes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditNoteDetails: async (id: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('creditNoteDetails', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('creditNoteDetails', 'culture', culture)
            const localVarPath = `/{culture}/credit-notes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditNoteEdit: async (id: number, culture: string, simpleDocument: SimpleDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('creditNoteEdit', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('creditNoteEdit', 'culture', culture)
            // verify required parameter 'simpleDocument' is not null or undefined
            assertParamExists('creditNoteEdit', 'simpleDocument', simpleDocument)
            const localVarPath = `/{culture}/credit-notes/simple-document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(simpleDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditNoteEdit2: async (id: number, culture: string, inlineDocument: InlineDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('creditNoteEdit2', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('creditNoteEdit2', 'culture', culture)
            // verify required parameter 'inlineDocument' is not null or undefined
            assertParamExists('creditNoteEdit2', 'inlineDocument', inlineDocument)
            const localVarPath = `/{culture}/credit-notes/inline-document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} culture 
         * @param {string} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditNoteGetCumulativeDocumentReferenceList: async (culture: string, ids?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('creditNoteGetCumulativeDocumentReferenceList', 'culture', culture)
            const localVarPath = `/{culture}/credit-notes/cumulative-references`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditNoteIndex: async (culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('creditNoteIndex', 'culture', culture)
            const localVarPath = `/{culture}/credit-notes`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sortBy !== undefined) {
                localVarQueryParameter['SortBy'] = sortBy;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['CurrentPage'] = currentPage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (filter !== undefined) {
                localVarQueryParameter['Filter'] = filter;
            }

            if (searchString !== undefined) {
                localVarQueryParameter['SearchString'] = searchString;
            }

            if (customDocumentModels !== undefined) {
                localVarQueryParameter['CustomDocumentModels'] = customDocumentModels;
            }

            if (range !== undefined) {
                localVarQueryParameter['Range'] = range;
            }

            if (month !== undefined) {
                localVarQueryParameter['Month'] = month;
            }

            if (year !== undefined) {
                localVarQueryParameter['Year'] = year;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['StartDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['EndDate'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditNoteReceivePayment: async (id: number, culture: string, paymentModel: PaymentModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('creditNoteReceivePayment', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('creditNoteReceivePayment', 'culture', culture)
            // verify required parameter 'paymentModel' is not null or undefined
            assertParamExists('creditNoteReceivePayment', 'paymentModel', paymentModel)
            const localVarPath = `/{culture}/credit-notes/{id}/payments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreditNoteApi - functional programming interface
 * @export
 */
export const CreditNoteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreditNoteApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditNoteChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditNoteChangeStatusByKey(documentId, statusKey, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditNoteCreate(culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageSent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditNoteCreate(culture, simpleDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditNoteCreate2(culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageSent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditNoteCreate2(culture, inlineDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditNoteDelete(id: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditNoteDelete(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditNoteDetails(id: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditNoteDetails(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditNoteEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditNoteEdit(id, culture, simpleDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditNoteEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditNoteEdit2(id, culture, inlineDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} culture 
         * @param {string} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditNoteGetCumulativeDocumentReferenceList(culture: string, ids?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditNoteGetCumulativeDocumentReferenceList(culture, ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditNoteIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditNoteIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditNoteReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditNoteReceivePayment(id, culture, paymentModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CreditNoteApi - factory interface
 * @export
 */
export const CreditNoteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreditNoteApiFp(configuration)
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditNoteChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.creditNoteChangeStatusByKey(documentId, statusKey, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditNoteCreate(culture: string, simpleDocument: SimpleDocument, options?: any): AxiosPromise<MessageSent> {
            return localVarFp.creditNoteCreate(culture, simpleDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditNoteCreate2(culture: string, inlineDocument: InlineDocument, options?: any): AxiosPromise<MessageSent> {
            return localVarFp.creditNoteCreate2(culture, inlineDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditNoteDelete(id: number, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.creditNoteDelete(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditNoteDetails(id: number, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.creditNoteDetails(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditNoteEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: any): AxiosPromise<any> {
            return localVarFp.creditNoteEdit(id, culture, simpleDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditNoteEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: any): AxiosPromise<any> {
            return localVarFp.creditNoteEdit2(id, culture, inlineDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} culture 
         * @param {string} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditNoteGetCumulativeDocumentReferenceList(culture: string, ids?: string, options?: any): AxiosPromise<any> {
            return localVarFp.creditNoteGetCumulativeDocumentReferenceList(culture, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditNoteIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: any): AxiosPromise<any> {
            return localVarFp.creditNoteIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditNoteReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: any): AxiosPromise<any> {
            return localVarFp.creditNoteReceivePayment(id, culture, paymentModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreditNoteApi - object-oriented interface
 * @export
 * @class CreditNoteApi
 * @extends {BaseAPI}
 */
export class CreditNoteApi extends BaseAPI {
    /**
     * 
     * @summary To change status by the document id and key
     * @param {number} documentId 
     * @param {string} statusKey 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditNoteApi
     */
    public creditNoteChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: AxiosRequestConfig) {
        return CreditNoteApiFp(this.configuration).creditNoteChangeStatusByKey(documentId, statusKey, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Create a document with SimpleDocument as the parameter
     * @param {string} culture 
     * @param {SimpleDocument} simpleDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditNoteApi
     */
    public creditNoteCreate(culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig) {
        return CreditNoteApiFp(this.configuration).creditNoteCreate(culture, simpleDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Create a document with InlineDocument as the parameter
     * @param {string} culture 
     * @param {InlineDocument} inlineDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditNoteApi
     */
    public creditNoteCreate2(culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig) {
        return CreditNoteApiFp(this.configuration).creditNoteCreate2(culture, inlineDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To delete the document given a list of documentids
     * @param {number} id 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditNoteApi
     */
    public creditNoteDelete(id: number, culture: string, options?: AxiosRequestConfig) {
        return CreditNoteApiFp(this.configuration).creditNoteDelete(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To get details of a document
     * @param {number} id Sql DocumentId
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditNoteApi
     */
    public creditNoteDetails(id: number, culture: string, options?: AxiosRequestConfig) {
        return CreditNoteApiFp(this.configuration).creditNoteDetails(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Update a document with simpleDocument as the parameter
     * @param {number} id 
     * @param {string} culture 
     * @param {SimpleDocument} simpleDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditNoteApi
     */
    public creditNoteEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig) {
        return CreditNoteApiFp(this.configuration).creditNoteEdit(id, culture, simpleDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Update a document with inlineDocument as the parameter
     * @param {number} id 
     * @param {string} culture 
     * @param {InlineDocument} inlineDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditNoteApi
     */
    public creditNoteEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig) {
        return CreditNoteApiFp(this.configuration).creditNoteEdit2(id, culture, inlineDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} culture 
     * @param {string} [ids] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditNoteApi
     */
    public creditNoteGetCumulativeDocumentReferenceList(culture: string, ids?: string, options?: AxiosRequestConfig) {
        return CreditNoteApiFp(this.configuration).creditNoteGetCumulativeDocumentReferenceList(culture, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To query for documents.
     * @param {string} culture 
     * @param {string} [sortBy] 
     * @param {string} [currentPage] 
     * @param {string} [pageSize] 
     * @param {string} [filter] 
     * @param {string} [searchString] 
     * @param {string} [customDocumentModels] 
     * @param {string} [range] 
     * @param {string} [month] 
     * @param {string} [year] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditNoteApi
     */
    public creditNoteIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: AxiosRequestConfig) {
        return CreditNoteApiFp(this.configuration).creditNoteIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Accept payment with the paymentModel
     * @param {number} id 
     * @param {string} culture 
     * @param {PaymentModel} paymentModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditNoteApi
     */
    public creditNoteReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: AxiosRequestConfig) {
        return CreditNoteApiFp(this.configuration).creditNoteReceivePayment(id, culture, paymentModel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DebitNoteApi - axios parameter creator
 * @export
 */
export const DebitNoteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debitNoteChangeStatusByKey: async (documentId: number, statusKey: string, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('debitNoteChangeStatusByKey', 'documentId', documentId)
            // verify required parameter 'statusKey' is not null or undefined
            assertParamExists('debitNoteChangeStatusByKey', 'statusKey', statusKey)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('debitNoteChangeStatusByKey', 'culture', culture)
            const localVarPath = `/{culture}/debit-notes/{documentId}/status-key/{statusKey}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"statusKey"}}`, encodeURIComponent(String(statusKey)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debitNoteCreate: async (culture: string, simpleDocument: SimpleDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('debitNoteCreate', 'culture', culture)
            // verify required parameter 'simpleDocument' is not null or undefined
            assertParamExists('debitNoteCreate', 'simpleDocument', simpleDocument)
            const localVarPath = `/{culture}/debit-notes/simple-document`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(simpleDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debitNoteCreate2: async (culture: string, inlineDocument: InlineDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('debitNoteCreate2', 'culture', culture)
            // verify required parameter 'inlineDocument' is not null or undefined
            assertParamExists('debitNoteCreate2', 'inlineDocument', inlineDocument)
            const localVarPath = `/{culture}/debit-notes/inline-document`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debitNoteDelete: async (id: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('debitNoteDelete', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('debitNoteDelete', 'culture', culture)
            const localVarPath = `/{culture}/debit-notes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debitNoteDetails: async (id: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('debitNoteDetails', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('debitNoteDetails', 'culture', culture)
            const localVarPath = `/{culture}/debit-notes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debitNoteEdit: async (id: number, culture: string, simpleDocument: SimpleDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('debitNoteEdit', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('debitNoteEdit', 'culture', culture)
            // verify required parameter 'simpleDocument' is not null or undefined
            assertParamExists('debitNoteEdit', 'simpleDocument', simpleDocument)
            const localVarPath = `/{culture}/debit-notes/simple-document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(simpleDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debitNoteEdit2: async (id: number, culture: string, inlineDocument: InlineDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('debitNoteEdit2', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('debitNoteEdit2', 'culture', culture)
            // verify required parameter 'inlineDocument' is not null or undefined
            assertParamExists('debitNoteEdit2', 'inlineDocument', inlineDocument)
            const localVarPath = `/{culture}/debit-notes/inline-document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} culture 
         * @param {string} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debitNoteGetCumulativeDocumentReferenceList: async (culture: string, ids?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('debitNoteGetCumulativeDocumentReferenceList', 'culture', culture)
            const localVarPath = `/{culture}/debit-notes/cumulative-references`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debitNoteIndex: async (culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('debitNoteIndex', 'culture', culture)
            const localVarPath = `/{culture}/debit-notes`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sortBy !== undefined) {
                localVarQueryParameter['SortBy'] = sortBy;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['CurrentPage'] = currentPage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (filter !== undefined) {
                localVarQueryParameter['Filter'] = filter;
            }

            if (searchString !== undefined) {
                localVarQueryParameter['SearchString'] = searchString;
            }

            if (customDocumentModels !== undefined) {
                localVarQueryParameter['CustomDocumentModels'] = customDocumentModels;
            }

            if (range !== undefined) {
                localVarQueryParameter['Range'] = range;
            }

            if (month !== undefined) {
                localVarQueryParameter['Month'] = month;
            }

            if (year !== undefined) {
                localVarQueryParameter['Year'] = year;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['StartDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['EndDate'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debitNoteReceivePayment: async (id: number, culture: string, paymentModel: PaymentModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('debitNoteReceivePayment', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('debitNoteReceivePayment', 'culture', culture)
            // verify required parameter 'paymentModel' is not null or undefined
            assertParamExists('debitNoteReceivePayment', 'paymentModel', paymentModel)
            const localVarPath = `/{culture}/debit-notes/{id}/payments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DebitNoteApi - functional programming interface
 * @export
 */
export const DebitNoteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DebitNoteApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async debitNoteChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.debitNoteChangeStatusByKey(documentId, statusKey, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async debitNoteCreate(culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageSent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.debitNoteCreate(culture, simpleDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async debitNoteCreate2(culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageSent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.debitNoteCreate2(culture, inlineDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async debitNoteDelete(id: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.debitNoteDelete(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async debitNoteDetails(id: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.debitNoteDetails(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async debitNoteEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.debitNoteEdit(id, culture, simpleDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async debitNoteEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.debitNoteEdit2(id, culture, inlineDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} culture 
         * @param {string} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async debitNoteGetCumulativeDocumentReferenceList(culture: string, ids?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.debitNoteGetCumulativeDocumentReferenceList(culture, ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async debitNoteIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.debitNoteIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async debitNoteReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.debitNoteReceivePayment(id, culture, paymentModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DebitNoteApi - factory interface
 * @export
 */
export const DebitNoteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DebitNoteApiFp(configuration)
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debitNoteChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.debitNoteChangeStatusByKey(documentId, statusKey, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debitNoteCreate(culture: string, simpleDocument: SimpleDocument, options?: any): AxiosPromise<MessageSent> {
            return localVarFp.debitNoteCreate(culture, simpleDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debitNoteCreate2(culture: string, inlineDocument: InlineDocument, options?: any): AxiosPromise<MessageSent> {
            return localVarFp.debitNoteCreate2(culture, inlineDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debitNoteDelete(id: number, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.debitNoteDelete(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debitNoteDetails(id: number, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.debitNoteDetails(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debitNoteEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: any): AxiosPromise<any> {
            return localVarFp.debitNoteEdit(id, culture, simpleDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debitNoteEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: any): AxiosPromise<any> {
            return localVarFp.debitNoteEdit2(id, culture, inlineDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} culture 
         * @param {string} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debitNoteGetCumulativeDocumentReferenceList(culture: string, ids?: string, options?: any): AxiosPromise<any> {
            return localVarFp.debitNoteGetCumulativeDocumentReferenceList(culture, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debitNoteIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: any): AxiosPromise<any> {
            return localVarFp.debitNoteIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debitNoteReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: any): AxiosPromise<any> {
            return localVarFp.debitNoteReceivePayment(id, culture, paymentModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DebitNoteApi - object-oriented interface
 * @export
 * @class DebitNoteApi
 * @extends {BaseAPI}
 */
export class DebitNoteApi extends BaseAPI {
    /**
     * 
     * @summary To change status by the document id and key
     * @param {number} documentId 
     * @param {string} statusKey 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebitNoteApi
     */
    public debitNoteChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: AxiosRequestConfig) {
        return DebitNoteApiFp(this.configuration).debitNoteChangeStatusByKey(documentId, statusKey, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Create a document with SimpleDocument as the parameter
     * @param {string} culture 
     * @param {SimpleDocument} simpleDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebitNoteApi
     */
    public debitNoteCreate(culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig) {
        return DebitNoteApiFp(this.configuration).debitNoteCreate(culture, simpleDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Create a document with InlineDocument as the parameter
     * @param {string} culture 
     * @param {InlineDocument} inlineDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebitNoteApi
     */
    public debitNoteCreate2(culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig) {
        return DebitNoteApiFp(this.configuration).debitNoteCreate2(culture, inlineDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To delete the document given a list of documentids
     * @param {number} id 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebitNoteApi
     */
    public debitNoteDelete(id: number, culture: string, options?: AxiosRequestConfig) {
        return DebitNoteApiFp(this.configuration).debitNoteDelete(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To get details of a document
     * @param {number} id Sql DocumentId
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebitNoteApi
     */
    public debitNoteDetails(id: number, culture: string, options?: AxiosRequestConfig) {
        return DebitNoteApiFp(this.configuration).debitNoteDetails(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Update a document with simpleDocument as the parameter
     * @param {number} id 
     * @param {string} culture 
     * @param {SimpleDocument} simpleDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebitNoteApi
     */
    public debitNoteEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig) {
        return DebitNoteApiFp(this.configuration).debitNoteEdit(id, culture, simpleDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Update a document with inlineDocument as the parameter
     * @param {number} id 
     * @param {string} culture 
     * @param {InlineDocument} inlineDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebitNoteApi
     */
    public debitNoteEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig) {
        return DebitNoteApiFp(this.configuration).debitNoteEdit2(id, culture, inlineDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} culture 
     * @param {string} [ids] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebitNoteApi
     */
    public debitNoteGetCumulativeDocumentReferenceList(culture: string, ids?: string, options?: AxiosRequestConfig) {
        return DebitNoteApiFp(this.configuration).debitNoteGetCumulativeDocumentReferenceList(culture, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To query for documents.
     * @param {string} culture 
     * @param {string} [sortBy] 
     * @param {string} [currentPage] 
     * @param {string} [pageSize] 
     * @param {string} [filter] 
     * @param {string} [searchString] 
     * @param {string} [customDocumentModels] 
     * @param {string} [range] 
     * @param {string} [month] 
     * @param {string} [year] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebitNoteApi
     */
    public debitNoteIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: AxiosRequestConfig) {
        return DebitNoteApiFp(this.configuration).debitNoteIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Accept payment with the paymentModel
     * @param {number} id 
     * @param {string} culture 
     * @param {PaymentModel} paymentModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebitNoteApi
     */
    public debitNoteReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: AxiosRequestConfig) {
        return DebitNoteApiFp(this.configuration).debitNoteReceivePayment(id, culture, paymentModel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EmployeeApi - axios parameter creator
 * @export
 */
export const EmployeeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Count employees
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeeCount: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Employee/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Employee
         * @param {EmployeeModel} employeeModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeeCreate: async (employeeModel: EmployeeModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'employeeModel' is not null or undefined
            assertParamExists('employeeCreate', 'employeeModel', employeeModel)
            const localVarPath = `/Employee`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(employeeModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Employee
         * @param {EmployeeModel} employeeModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeeEdit: async (employeeModel: EmployeeModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'employeeModel' is not null or undefined
            assertParamExists('employeeEdit', 'employeeModel', employeeModel)
            const localVarPath = `/Employee`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(employeeModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get employee by Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeeGetById: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('employeeGetById', 'id', id)
            const localVarPath = `/Employee/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get employee list with payrollQuery model
         * @param {PayrollQuery} payrollQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeeGetList: async (payrollQuery: PayrollQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payrollQuery' is not null or undefined
            assertParamExists('employeeGetList', 'payrollQuery', payrollQuery)
            const localVarPath = `/Employee`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payrollQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete/Remove Employee by Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeeRemove: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('employeeRemove', 'id', id)
            const localVarPath = `/Employee/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmployeeApi - functional programming interface
 * @export
 */
export const EmployeeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EmployeeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Count employees
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async employeeCount(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.employeeCount(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create Employee
         * @param {EmployeeModel} employeeModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async employeeCreate(employeeModel: EmployeeModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.employeeCreate(employeeModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Employee
         * @param {EmployeeModel} employeeModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async employeeEdit(employeeModel: EmployeeModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.employeeEdit(employeeModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get employee by Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async employeeGetById(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.employeeGetById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get employee list with payrollQuery model
         * @param {PayrollQuery} payrollQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async employeeGetList(payrollQuery: PayrollQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.employeeGetList(payrollQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete/Remove Employee by Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async employeeRemove(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.employeeRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EmployeeApi - factory interface
 * @export
 */
export const EmployeeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EmployeeApiFp(configuration)
    return {
        /**
         * 
         * @summary Count employees
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeeCount(options?: any): AxiosPromise<any> {
            return localVarFp.employeeCount(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Employee
         * @param {EmployeeModel} employeeModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeeCreate(employeeModel: EmployeeModel, options?: any): AxiosPromise<any> {
            return localVarFp.employeeCreate(employeeModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Employee
         * @param {EmployeeModel} employeeModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeeEdit(employeeModel: EmployeeModel, options?: any): AxiosPromise<any> {
            return localVarFp.employeeEdit(employeeModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get employee by Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeeGetById(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.employeeGetById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get employee list with payrollQuery model
         * @param {PayrollQuery} payrollQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeeGetList(payrollQuery: PayrollQuery, options?: any): AxiosPromise<any> {
            return localVarFp.employeeGetList(payrollQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete/Remove Employee by Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeeRemove(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.employeeRemove(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EmployeeApi - object-oriented interface
 * @export
 * @class EmployeeApi
 * @extends {BaseAPI}
 */
export class EmployeeApi extends BaseAPI {
    /**
     * 
     * @summary Count employees
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeApi
     */
    public employeeCount(options?: AxiosRequestConfig) {
        return EmployeeApiFp(this.configuration).employeeCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Employee
     * @param {EmployeeModel} employeeModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeApi
     */
    public employeeCreate(employeeModel: EmployeeModel, options?: AxiosRequestConfig) {
        return EmployeeApiFp(this.configuration).employeeCreate(employeeModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Employee
     * @param {EmployeeModel} employeeModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeApi
     */
    public employeeEdit(employeeModel: EmployeeModel, options?: AxiosRequestConfig) {
        return EmployeeApiFp(this.configuration).employeeEdit(employeeModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get employee by Id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeApi
     */
    public employeeGetById(id: number, options?: AxiosRequestConfig) {
        return EmployeeApiFp(this.configuration).employeeGetById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get employee list with payrollQuery model
     * @param {PayrollQuery} payrollQuery 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeApi
     */
    public employeeGetList(payrollQuery: PayrollQuery, options?: AxiosRequestConfig) {
        return EmployeeApiFp(this.configuration).employeeGetList(payrollQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete/Remove Employee by Id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeApi
     */
    public employeeRemove(id: number, options?: AxiosRequestConfig) {
        return EmployeeApiFp(this.configuration).employeeRemove(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExpenseApi - axios parameter creator
 * @export
 */
export const ExpenseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseChangeStatusByKey: async (documentId: number, statusKey: string, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('expenseChangeStatusByKey', 'documentId', documentId)
            // verify required parameter 'statusKey' is not null or undefined
            assertParamExists('expenseChangeStatusByKey', 'statusKey', statusKey)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('expenseChangeStatusByKey', 'culture', culture)
            const localVarPath = `/{culture}/expenses/{documentId}/status-key/{statusKey}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"statusKey"}}`, encodeURIComponent(String(statusKey)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseCreate: async (culture: string, simpleDocument: SimpleDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('expenseCreate', 'culture', culture)
            // verify required parameter 'simpleDocument' is not null or undefined
            assertParamExists('expenseCreate', 'simpleDocument', simpleDocument)
            const localVarPath = `/{culture}/expenses/simple-document`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(simpleDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseCreate2: async (culture: string, inlineDocument: InlineDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('expenseCreate2', 'culture', culture)
            // verify required parameter 'inlineDocument' is not null or undefined
            assertParamExists('expenseCreate2', 'inlineDocument', inlineDocument)
            const localVarPath = `/{culture}/expenses/inline-document`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseDelete: async (id: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('expenseDelete', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('expenseDelete', 'culture', culture)
            const localVarPath = `/{culture}/expenses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseDetails: async (id: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('expenseDetails', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('expenseDetails', 'culture', culture)
            const localVarPath = `/{culture}/expenses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseEdit: async (id: number, culture: string, simpleDocument: SimpleDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('expenseEdit', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('expenseEdit', 'culture', culture)
            // verify required parameter 'simpleDocument' is not null or undefined
            assertParamExists('expenseEdit', 'simpleDocument', simpleDocument)
            const localVarPath = `/{culture}/expenses/simple-document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(simpleDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseEdit2: async (id: number, culture: string, inlineDocument: InlineDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('expenseEdit2', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('expenseEdit2', 'culture', culture)
            // verify required parameter 'inlineDocument' is not null or undefined
            assertParamExists('expenseEdit2', 'inlineDocument', inlineDocument)
            const localVarPath = `/{culture}/expenses/inline-document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseGetBusinessCategories: async (culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('expenseGetBusinessCategories', 'culture', culture)
            const localVarPath = `/{culture}/expenses/categories/business`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseGetBusinessCategoriesWithoutAsset: async (culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('expenseGetBusinessCategoriesWithoutAsset', 'culture', culture)
            const localVarPath = `/{culture}/expenses/categories/business-without-asset`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseGetChartOfAccounts: async (culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('expenseGetChartOfAccounts', 'culture', culture)
            const localVarPath = `/{culture}/expenses/categories/accounting`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseGetChartOfAccountsWithoutAsset: async (culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('expenseGetChartOfAccountsWithoutAsset', 'culture', culture)
            const localVarPath = `/{culture}/expenses/categories/accounting-without-asset`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseIndex: async (culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('expenseIndex', 'culture', culture)
            const localVarPath = `/{culture}/expenses`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sortBy !== undefined) {
                localVarQueryParameter['SortBy'] = sortBy;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['CurrentPage'] = currentPage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (filter !== undefined) {
                localVarQueryParameter['Filter'] = filter;
            }

            if (searchString !== undefined) {
                localVarQueryParameter['SearchString'] = searchString;
            }

            if (customDocumentModels !== undefined) {
                localVarQueryParameter['CustomDocumentModels'] = customDocumentModels;
            }

            if (range !== undefined) {
                localVarQueryParameter['Range'] = range;
            }

            if (month !== undefined) {
                localVarQueryParameter['Month'] = month;
            }

            if (year !== undefined) {
                localVarQueryParameter['Year'] = year;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['StartDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['EndDate'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseReceivePayment: async (id: number, culture: string, paymentModel: PaymentModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('expenseReceivePayment', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('expenseReceivePayment', 'culture', culture)
            // verify required parameter 'paymentModel' is not null or undefined
            assertParamExists('expenseReceivePayment', 'paymentModel', paymentModel)
            const localVarPath = `/{culture}/expenses/{id}/payments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExpenseApi - functional programming interface
 * @export
 */
export const ExpenseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExpenseApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expenseChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expenseChangeStatusByKey(documentId, statusKey, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expenseCreate(culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageSent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expenseCreate(culture, simpleDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expenseCreate2(culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageSent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expenseCreate2(culture, inlineDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expenseDelete(id: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expenseDelete(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expenseDetails(id: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expenseDetails(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expenseEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expenseEdit(id, culture, simpleDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expenseEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expenseEdit2(id, culture, inlineDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expenseGetBusinessCategories(culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expenseGetBusinessCategories(culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expenseGetBusinessCategoriesWithoutAsset(culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expenseGetBusinessCategoriesWithoutAsset(culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expenseGetChartOfAccounts(culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expenseGetChartOfAccounts(culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expenseGetChartOfAccountsWithoutAsset(culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expenseGetChartOfAccountsWithoutAsset(culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expenseIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expenseIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expenseReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expenseReceivePayment(id, culture, paymentModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExpenseApi - factory interface
 * @export
 */
export const ExpenseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExpenseApiFp(configuration)
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.expenseChangeStatusByKey(documentId, statusKey, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseCreate(culture: string, simpleDocument: SimpleDocument, options?: any): AxiosPromise<MessageSent> {
            return localVarFp.expenseCreate(culture, simpleDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseCreate2(culture: string, inlineDocument: InlineDocument, options?: any): AxiosPromise<MessageSent> {
            return localVarFp.expenseCreate2(culture, inlineDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseDelete(id: number, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.expenseDelete(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseDetails(id: number, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.expenseDetails(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: any): AxiosPromise<any> {
            return localVarFp.expenseEdit(id, culture, simpleDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: any): AxiosPromise<any> {
            return localVarFp.expenseEdit2(id, culture, inlineDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseGetBusinessCategories(culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.expenseGetBusinessCategories(culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseGetBusinessCategoriesWithoutAsset(culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.expenseGetBusinessCategoriesWithoutAsset(culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseGetChartOfAccounts(culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.expenseGetChartOfAccounts(culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseGetChartOfAccountsWithoutAsset(culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.expenseGetChartOfAccountsWithoutAsset(culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: any): AxiosPromise<any> {
            return localVarFp.expenseIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: any): AxiosPromise<any> {
            return localVarFp.expenseReceivePayment(id, culture, paymentModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExpenseApi - object-oriented interface
 * @export
 * @class ExpenseApi
 * @extends {BaseAPI}
 */
export class ExpenseApi extends BaseAPI {
    /**
     * 
     * @summary To change status by the document id and key
     * @param {number} documentId 
     * @param {string} statusKey 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpenseApi
     */
    public expenseChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: AxiosRequestConfig) {
        return ExpenseApiFp(this.configuration).expenseChangeStatusByKey(documentId, statusKey, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Create a document with SimpleDocument as the parameter
     * @param {string} culture 
     * @param {SimpleDocument} simpleDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpenseApi
     */
    public expenseCreate(culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig) {
        return ExpenseApiFp(this.configuration).expenseCreate(culture, simpleDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Create a document with InlineDocument as the parameter
     * @param {string} culture 
     * @param {InlineDocument} inlineDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpenseApi
     */
    public expenseCreate2(culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig) {
        return ExpenseApiFp(this.configuration).expenseCreate2(culture, inlineDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To delete the document given a list of documentids
     * @param {number} id 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpenseApi
     */
    public expenseDelete(id: number, culture: string, options?: AxiosRequestConfig) {
        return ExpenseApiFp(this.configuration).expenseDelete(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To get details of a document
     * @param {number} id Sql DocumentId
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpenseApi
     */
    public expenseDetails(id: number, culture: string, options?: AxiosRequestConfig) {
        return ExpenseApiFp(this.configuration).expenseDetails(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Update a document with simpleDocument as the parameter
     * @param {number} id 
     * @param {string} culture 
     * @param {SimpleDocument} simpleDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpenseApi
     */
    public expenseEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig) {
        return ExpenseApiFp(this.configuration).expenseEdit(id, culture, simpleDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Update a document with inlineDocument as the parameter
     * @param {number} id 
     * @param {string} culture 
     * @param {InlineDocument} inlineDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpenseApi
     */
    public expenseEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig) {
        return ExpenseApiFp(this.configuration).expenseEdit2(id, culture, inlineDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpenseApi
     */
    public expenseGetBusinessCategories(culture: string, options?: AxiosRequestConfig) {
        return ExpenseApiFp(this.configuration).expenseGetBusinessCategories(culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpenseApi
     */
    public expenseGetBusinessCategoriesWithoutAsset(culture: string, options?: AxiosRequestConfig) {
        return ExpenseApiFp(this.configuration).expenseGetBusinessCategoriesWithoutAsset(culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpenseApi
     */
    public expenseGetChartOfAccounts(culture: string, options?: AxiosRequestConfig) {
        return ExpenseApiFp(this.configuration).expenseGetChartOfAccounts(culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpenseApi
     */
    public expenseGetChartOfAccountsWithoutAsset(culture: string, options?: AxiosRequestConfig) {
        return ExpenseApiFp(this.configuration).expenseGetChartOfAccountsWithoutAsset(culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To query for documents.
     * @param {string} culture 
     * @param {string} [sortBy] 
     * @param {string} [currentPage] 
     * @param {string} [pageSize] 
     * @param {string} [filter] 
     * @param {string} [searchString] 
     * @param {string} [customDocumentModels] 
     * @param {string} [range] 
     * @param {string} [month] 
     * @param {string} [year] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpenseApi
     */
    public expenseIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: AxiosRequestConfig) {
        return ExpenseApiFp(this.configuration).expenseIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Accept payment with the paymentModel
     * @param {number} id 
     * @param {string} culture 
     * @param {PaymentModel} paymentModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpenseApi
     */
    public expenseReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: AxiosRequestConfig) {
        return ExpenseApiFp(this.configuration).expenseReceivePayment(id, culture, paymentModel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductCategoryApi - axios parameter creator
 * @export
 */
export const ProductCategoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} culture 
         * @param {ProductCategory} productCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoryCreateProductCategory: async (culture: string, productCategory: ProductCategory, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('productCategoryCreateProductCategory', 'culture', culture)
            // verify required parameter 'productCategory' is not null or undefined
            assertParamExists('productCategoryCreateProductCategory', 'productCategory', productCategory)
            const localVarPath = `/{culture}/products/categories`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoryDeleteProductCategory: async (id: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productCategoryDeleteProductCategory', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('productCategoryDeleteProductCategory', 'culture', culture)
            const localVarPath = `/{culture}/products/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} culture 
         * @param {number} [currentPage] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoryGetProductCategory: async (culture: string, currentPage?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('productCategoryGetProductCategory', 'culture', culture)
            const localVarPath = `/{culture}/products/categories`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {ProductCategory} productCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoryUpdateProductCategory: async (id: number, culture: string, productCategory: ProductCategory, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productCategoryUpdateProductCategory', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('productCategoryUpdateProductCategory', 'culture', culture)
            // verify required parameter 'productCategory' is not null or undefined
            assertParamExists('productCategoryUpdateProductCategory', 'productCategory', productCategory)
            const localVarPath = `/{culture}/products/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductCategoryApi - functional programming interface
 * @export
 */
export const ProductCategoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductCategoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} culture 
         * @param {ProductCategory} productCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productCategoryCreateProductCategory(culture: string, productCategory: ProductCategory, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productCategoryCreateProductCategory(culture, productCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productCategoryDeleteProductCategory(id: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productCategoryDeleteProductCategory(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} culture 
         * @param {number} [currentPage] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productCategoryGetProductCategory(culture: string, currentPage?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productCategoryGetProductCategory(culture, currentPage, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {ProductCategory} productCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productCategoryUpdateProductCategory(id: number, culture: string, productCategory: ProductCategory, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productCategoryUpdateProductCategory(id, culture, productCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductCategoryApi - factory interface
 * @export
 */
export const ProductCategoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductCategoryApiFp(configuration)
    return {
        /**
         * 
         * @param {string} culture 
         * @param {ProductCategory} productCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoryCreateProductCategory(culture: string, productCategory: ProductCategory, options?: any): AxiosPromise<any> {
            return localVarFp.productCategoryCreateProductCategory(culture, productCategory, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoryDeleteProductCategory(id: number, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.productCategoryDeleteProductCategory(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} culture 
         * @param {number} [currentPage] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoryGetProductCategory(culture: string, currentPage?: number, pageSize?: number, options?: any): AxiosPromise<Array<ProductCategory>> {
            return localVarFp.productCategoryGetProductCategory(culture, currentPage, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {ProductCategory} productCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoryUpdateProductCategory(id: number, culture: string, productCategory: ProductCategory, options?: any): AxiosPromise<any> {
            return localVarFp.productCategoryUpdateProductCategory(id, culture, productCategory, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductCategoryApi - object-oriented interface
 * @export
 * @class ProductCategoryApi
 * @extends {BaseAPI}
 */
export class ProductCategoryApi extends BaseAPI {
    /**
     * 
     * @param {string} culture 
     * @param {ProductCategory} productCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoryApi
     */
    public productCategoryCreateProductCategory(culture: string, productCategory: ProductCategory, options?: AxiosRequestConfig) {
        return ProductCategoryApiFp(this.configuration).productCategoryCreateProductCategory(culture, productCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoryApi
     */
    public productCategoryDeleteProductCategory(id: number, culture: string, options?: AxiosRequestConfig) {
        return ProductCategoryApiFp(this.configuration).productCategoryDeleteProductCategory(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} culture 
     * @param {number} [currentPage] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoryApi
     */
    public productCategoryGetProductCategory(culture: string, currentPage?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return ProductCategoryApiFp(this.configuration).productCategoryGetProductCategory(culture, currentPage, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} culture 
     * @param {ProductCategory} productCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoryApi
     */
    public productCategoryUpdateProductCategory(id: number, culture: string, productCategory: ProductCategory, options?: AxiosRequestConfig) {
        return ProductCategoryApiFp(this.configuration).productCategoryUpdateProductCategory(id, culture, productCategory, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductInventoryApi - axios parameter creator
 * @export
 */
export const ProductInventoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} culture 
         * @param {StockCard} stockCard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productInventoryAdjust: async (culture: string, stockCard: StockCard, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('productInventoryAdjust', 'culture', culture)
            // verify required parameter 'stockCard' is not null or undefined
            assertParamExists('productInventoryAdjust', 'stockCard', stockCard)
            const localVarPath = `/{culture}/product-inventories/adjust`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stockCard, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productInventoryDeleteProductInventory: async (id: string, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productInventoryDeleteProductInventory', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('productInventoryDeleteProductInventory', 'culture', culture)
            const localVarPath = `/{culture}/product-inventories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productInventoryGetList: async (id: number, culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productInventoryGetList', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('productInventoryGetList', 'culture', culture)
            const localVarPath = `/{culture}/product-inventories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sortBy !== undefined) {
                localVarQueryParameter['SortBy'] = sortBy;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['CurrentPage'] = currentPage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (filter !== undefined) {
                localVarQueryParameter['Filter'] = filter;
            }

            if (searchString !== undefined) {
                localVarQueryParameter['SearchString'] = searchString;
            }

            if (customDocumentModels !== undefined) {
                localVarQueryParameter['CustomDocumentModels'] = customDocumentModels;
            }

            if (range !== undefined) {
                localVarQueryParameter['Range'] = range;
            }

            if (month !== undefined) {
                localVarQueryParameter['Month'] = month;
            }

            if (year !== undefined) {
                localVarQueryParameter['Year'] = year;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['StartDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['EndDate'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductInventoryApi - functional programming interface
 * @export
 */
export const ProductInventoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductInventoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} culture 
         * @param {StockCard} stockCard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productInventoryAdjust(culture: string, stockCard: StockCard, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productInventoryAdjust(culture, stockCard, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productInventoryDeleteProductInventory(id: string, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productInventoryDeleteProductInventory(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productInventoryGetList(id: number, culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productInventoryGetList(id, culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductInventoryApi - factory interface
 * @export
 */
export const ProductInventoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductInventoryApiFp(configuration)
    return {
        /**
         * 
         * @param {string} culture 
         * @param {StockCard} stockCard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productInventoryAdjust(culture: string, stockCard: StockCard, options?: any): AxiosPromise<any> {
            return localVarFp.productInventoryAdjust(culture, stockCard, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productInventoryDeleteProductInventory(id: string, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.productInventoryDeleteProductInventory(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productInventoryGetList(id: number, culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: any): AxiosPromise<any> {
            return localVarFp.productInventoryGetList(id, culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductInventoryApi - object-oriented interface
 * @export
 * @class ProductInventoryApi
 * @extends {BaseAPI}
 */
export class ProductInventoryApi extends BaseAPI {
    /**
     * 
     * @param {string} culture 
     * @param {StockCard} stockCard 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductInventoryApi
     */
    public productInventoryAdjust(culture: string, stockCard: StockCard, options?: AxiosRequestConfig) {
        return ProductInventoryApiFp(this.configuration).productInventoryAdjust(culture, stockCard, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductInventoryApi
     */
    public productInventoryDeleteProductInventory(id: string, culture: string, options?: AxiosRequestConfig) {
        return ProductInventoryApiFp(this.configuration).productInventoryDeleteProductInventory(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} culture 
     * @param {string} [sortBy] 
     * @param {string} [currentPage] 
     * @param {string} [pageSize] 
     * @param {string} [filter] 
     * @param {string} [searchString] 
     * @param {string} [customDocumentModels] 
     * @param {string} [range] 
     * @param {string} [month] 
     * @param {string} [year] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductInventoryApi
     */
    public productInventoryGetList(id: number, culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: AxiosRequestConfig) {
        return ProductInventoryApiFp(this.configuration).productInventoryGetList(id, culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductUnitApi - axios parameter creator
 * @export
 */
export const ProductUnitApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} culture 
         * @param {ProductUnit} productUnit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUnitCreateProductUnit: async (culture: string, productUnit: ProductUnit, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('productUnitCreateProductUnit', 'culture', culture)
            // verify required parameter 'productUnit' is not null or undefined
            assertParamExists('productUnitCreateProductUnit', 'productUnit', productUnit)
            const localVarPath = `/{culture}/products/units`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productUnit, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUnitDeleteProductUnit: async (id: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productUnitDeleteProductUnit', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('productUnitDeleteProductUnit', 'culture', culture)
            const localVarPath = `/{culture}/products/units/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUnitGetProductUnitList: async (culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('productUnitGetProductUnitList', 'culture', culture)
            const localVarPath = `/{culture}/products/units`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {ProductUnit} productUnit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUnitUpdateProductUnit: async (id: number, culture: string, productUnit: ProductUnit, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productUnitUpdateProductUnit', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('productUnitUpdateProductUnit', 'culture', culture)
            // verify required parameter 'productUnit' is not null or undefined
            assertParamExists('productUnitUpdateProductUnit', 'productUnit', productUnit)
            const localVarPath = `/{culture}/products/units/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productUnit, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductUnitApi - functional programming interface
 * @export
 */
export const ProductUnitApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductUnitApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} culture 
         * @param {ProductUnit} productUnit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productUnitCreateProductUnit(culture: string, productUnit: ProductUnit, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productUnitCreateProductUnit(culture, productUnit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productUnitDeleteProductUnit(id: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productUnitDeleteProductUnit(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productUnitGetProductUnitList(culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productUnitGetProductUnitList(culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {ProductUnit} productUnit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productUnitUpdateProductUnit(id: number, culture: string, productUnit: ProductUnit, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productUnitUpdateProductUnit(id, culture, productUnit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductUnitApi - factory interface
 * @export
 */
export const ProductUnitApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductUnitApiFp(configuration)
    return {
        /**
         * 
         * @param {string} culture 
         * @param {ProductUnit} productUnit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUnitCreateProductUnit(culture: string, productUnit: ProductUnit, options?: any): AxiosPromise<any> {
            return localVarFp.productUnitCreateProductUnit(culture, productUnit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUnitDeleteProductUnit(id: number, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.productUnitDeleteProductUnit(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUnitGetProductUnitList(culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.productUnitGetProductUnitList(culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {ProductUnit} productUnit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUnitUpdateProductUnit(id: number, culture: string, productUnit: ProductUnit, options?: any): AxiosPromise<any> {
            return localVarFp.productUnitUpdateProductUnit(id, culture, productUnit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductUnitApi - object-oriented interface
 * @export
 * @class ProductUnitApi
 * @extends {BaseAPI}
 */
export class ProductUnitApi extends BaseAPI {
    /**
     * 
     * @param {string} culture 
     * @param {ProductUnit} productUnit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductUnitApi
     */
    public productUnitCreateProductUnit(culture: string, productUnit: ProductUnit, options?: AxiosRequestConfig) {
        return ProductUnitApiFp(this.configuration).productUnitCreateProductUnit(culture, productUnit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductUnitApi
     */
    public productUnitDeleteProductUnit(id: number, culture: string, options?: AxiosRequestConfig) {
        return ProductUnitApiFp(this.configuration).productUnitDeleteProductUnit(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductUnitApi
     */
    public productUnitGetProductUnitList(culture: string, options?: AxiosRequestConfig) {
        return ProductUnitApiFp(this.configuration).productUnitGetProductUnitList(culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} culture 
     * @param {ProductUnit} productUnit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductUnitApi
     */
    public productUnitUpdateProductUnit(id: number, culture: string, productUnit: ProductUnit, options?: AxiosRequestConfig) {
        return ProductUnitApiFp(this.configuration).productUnitUpdateProductUnit(id, culture, productUnit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} culture 
         * @param {ProductResult} productResult 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsCreate: async (culture: string, productResult: ProductResult, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('productsCreate', 'culture', culture)
            // verify required parameter 'productResult' is not null or undefined
            assertParamExists('productsCreate', 'productResult', productResult)
            const localVarPath = `/{culture}/Products`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productResult, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGetById: async (id: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productsGetById', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('productsGetById', 'culture', culture)
            const localVarPath = `/{culture}/Products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGetList: async (culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, id?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('productsGetList', 'culture', culture)
            const localVarPath = `/{culture}/Products`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sortBy !== undefined) {
                localVarQueryParameter['SortBy'] = sortBy;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['CurrentPage'] = currentPage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (filter !== undefined) {
                localVarQueryParameter['Filter'] = filter;
            }

            if (searchString !== undefined) {
                localVarQueryParameter['SearchString'] = searchString;
            }

            if (customDocumentModels !== undefined) {
                localVarQueryParameter['CustomDocumentModels'] = customDocumentModels;
            }

            if (range !== undefined) {
                localVarQueryParameter['Range'] = range;
            }

            if (month !== undefined) {
                localVarQueryParameter['Month'] = month;
            }

            if (year !== undefined) {
                localVarQueryParameter['Year'] = year;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['StartDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['EndDate'] = endDate;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsRemove: async (id: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productsRemove', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('productsRemove', 'culture', culture)
            const localVarPath = `/{culture}/Products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsSearch: async (culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('productsSearch', 'culture', culture)
            const localVarPath = `/{culture}/Products/search`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sortBy !== undefined) {
                localVarQueryParameter['SortBy'] = sortBy;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['CurrentPage'] = currentPage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (filter !== undefined) {
                localVarQueryParameter['Filter'] = filter;
            }

            if (searchString !== undefined) {
                localVarQueryParameter['SearchString'] = searchString;
            }

            if (customDocumentModels !== undefined) {
                localVarQueryParameter['CustomDocumentModels'] = customDocumentModels;
            }

            if (range !== undefined) {
                localVarQueryParameter['Range'] = range;
            }

            if (month !== undefined) {
                localVarQueryParameter['Month'] = month;
            }

            if (year !== undefined) {
                localVarQueryParameter['Year'] = year;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['StartDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['EndDate'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {ProductResult} productResult 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsUpdate: async (id: number, culture: string, productResult: ProductResult, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productsUpdate', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('productsUpdate', 'culture', culture)
            // verify required parameter 'productResult' is not null or undefined
            assertParamExists('productsUpdate', 'productResult', productResult)
            const localVarPath = `/{culture}/Products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productResult, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} culture 
         * @param {ProductResult} productResult 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsCreate(culture: string, productResult: ProductResult, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIResponseOfISimpleListResultOfIProductResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsCreate(culture, productResult, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsGetById(id: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIResponseOfISimpleListResultOfIProductResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsGetById(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsGetList(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, id?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIResponseOfISimpleListResultOfIProductResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsGetList(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsRemove(id: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIResponseOfBoolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsRemove(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsSearch(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIResponseOfISimpleListResultOfIProductResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsSearch(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {ProductResult} productResult 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsUpdate(id: number, culture: string, productResult: ProductResult, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIResponseOfISimpleListResultOfIProductResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsUpdate(id, culture, productResult, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} culture 
         * @param {ProductResult} productResult 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsCreate(culture: string, productResult: ProductResult, options?: any): AxiosPromise<APIResponseOfISimpleListResultOfIProductResult> {
            return localVarFp.productsCreate(culture, productResult, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGetById(id: number, culture: string, options?: any): AxiosPromise<APIResponseOfISimpleListResultOfIProductResult> {
            return localVarFp.productsGetById(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGetList(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, id?: number, options?: any): AxiosPromise<APIResponseOfISimpleListResultOfIProductResult> {
            return localVarFp.productsGetList(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsRemove(id: number, culture: string, options?: any): AxiosPromise<APIResponseOfBoolean> {
            return localVarFp.productsRemove(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsSearch(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: any): AxiosPromise<APIResponseOfISimpleListResultOfIProductResult> {
            return localVarFp.productsSearch(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {ProductResult} productResult 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsUpdate(id: number, culture: string, productResult: ProductResult, options?: any): AxiosPromise<APIResponseOfISimpleListResultOfIProductResult> {
            return localVarFp.productsUpdate(id, culture, productResult, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * 
     * @param {string} culture 
     * @param {ProductResult} productResult 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsCreate(culture: string, productResult: ProductResult, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsCreate(culture, productResult, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsGetById(id: number, culture: string, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsGetById(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} culture 
     * @param {string} [sortBy] 
     * @param {string} [currentPage] 
     * @param {string} [pageSize] 
     * @param {string} [filter] 
     * @param {string} [searchString] 
     * @param {string} [customDocumentModels] 
     * @param {string} [range] 
     * @param {string} [month] 
     * @param {string} [year] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {number} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsGetList(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, id?: number, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsGetList(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsRemove(id: number, culture: string, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsRemove(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} culture 
     * @param {string} [sortBy] 
     * @param {string} [currentPage] 
     * @param {string} [pageSize] 
     * @param {string} [filter] 
     * @param {string} [searchString] 
     * @param {string} [customDocumentModels] 
     * @param {string} [range] 
     * @param {string} [month] 
     * @param {string} [year] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsSearch(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsSearch(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} culture 
     * @param {ProductResult} productResult 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsUpdate(id: number, culture: string, productResult: ProductResult, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsUpdate(id, culture, productResult, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PurchaseApi - axios parameter creator
 * @export
 */
export const PurchaseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseChangeStatusByKey: async (documentId: number, statusKey: string, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('purchaseChangeStatusByKey', 'documentId', documentId)
            // verify required parameter 'statusKey' is not null or undefined
            assertParamExists('purchaseChangeStatusByKey', 'statusKey', statusKey)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('purchaseChangeStatusByKey', 'culture', culture)
            const localVarPath = `/{culture}/purchases/{documentId}/status-key/{statusKey}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"statusKey"}}`, encodeURIComponent(String(statusKey)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseCreate: async (culture: string, simpleDocument: SimpleDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('purchaseCreate', 'culture', culture)
            // verify required parameter 'simpleDocument' is not null or undefined
            assertParamExists('purchaseCreate', 'simpleDocument', simpleDocument)
            const localVarPath = `/{culture}/purchases/simple-document`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(simpleDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseCreate2: async (culture: string, inlineDocument: InlineDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('purchaseCreate2', 'culture', culture)
            // verify required parameter 'inlineDocument' is not null or undefined
            assertParamExists('purchaseCreate2', 'inlineDocument', inlineDocument)
            const localVarPath = `/{culture}/purchases/inline-document`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseDelete: async (id: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('purchaseDelete', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('purchaseDelete', 'culture', culture)
            const localVarPath = `/{culture}/purchases/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseDetails: async (id: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('purchaseDetails', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('purchaseDetails', 'culture', culture)
            const localVarPath = `/{culture}/purchases/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseEdit: async (id: number, culture: string, simpleDocument: SimpleDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('purchaseEdit', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('purchaseEdit', 'culture', culture)
            // verify required parameter 'simpleDocument' is not null or undefined
            assertParamExists('purchaseEdit', 'simpleDocument', simpleDocument)
            const localVarPath = `/{culture}/purchases/simple-document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(simpleDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseEdit2: async (id: number, culture: string, inlineDocument: InlineDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('purchaseEdit2', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('purchaseEdit2', 'culture', culture)
            // verify required parameter 'inlineDocument' is not null or undefined
            assertParamExists('purchaseEdit2', 'inlineDocument', inlineDocument)
            const localVarPath = `/{culture}/purchases/inline-document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseIndex: async (culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('purchaseIndex', 'culture', culture)
            const localVarPath = `/{culture}/purchases`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sortBy !== undefined) {
                localVarQueryParameter['SortBy'] = sortBy;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['CurrentPage'] = currentPage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (filter !== undefined) {
                localVarQueryParameter['Filter'] = filter;
            }

            if (searchString !== undefined) {
                localVarQueryParameter['SearchString'] = searchString;
            }

            if (customDocumentModels !== undefined) {
                localVarQueryParameter['CustomDocumentModels'] = customDocumentModels;
            }

            if (range !== undefined) {
                localVarQueryParameter['Range'] = range;
            }

            if (month !== undefined) {
                localVarQueryParameter['Month'] = month;
            }

            if (year !== undefined) {
                localVarQueryParameter['Year'] = year;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['StartDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['EndDate'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseReceivePayment: async (id: number, culture: string, paymentModel: PaymentModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('purchaseReceivePayment', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('purchaseReceivePayment', 'culture', culture)
            // verify required parameter 'paymentModel' is not null or undefined
            assertParamExists('purchaseReceivePayment', 'paymentModel', paymentModel)
            const localVarPath = `/{culture}/purchases/{id}/payments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PurchaseApi - functional programming interface
 * @export
 */
export const PurchaseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PurchaseApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchaseChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseChangeStatusByKey(documentId, statusKey, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchaseCreate(culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageSent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseCreate(culture, simpleDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchaseCreate2(culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageSent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseCreate2(culture, inlineDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchaseDelete(id: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseDelete(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchaseDetails(id: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseDetails(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchaseEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseEdit(id, culture, simpleDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchaseEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseEdit2(id, culture, inlineDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchaseIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchaseReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseReceivePayment(id, culture, paymentModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PurchaseApi - factory interface
 * @export
 */
export const PurchaseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PurchaseApiFp(configuration)
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.purchaseChangeStatusByKey(documentId, statusKey, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseCreate(culture: string, simpleDocument: SimpleDocument, options?: any): AxiosPromise<MessageSent> {
            return localVarFp.purchaseCreate(culture, simpleDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseCreate2(culture: string, inlineDocument: InlineDocument, options?: any): AxiosPromise<MessageSent> {
            return localVarFp.purchaseCreate2(culture, inlineDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseDelete(id: number, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.purchaseDelete(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseDetails(id: number, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.purchaseDetails(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: any): AxiosPromise<any> {
            return localVarFp.purchaseEdit(id, culture, simpleDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: any): AxiosPromise<any> {
            return localVarFp.purchaseEdit2(id, culture, inlineDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: any): AxiosPromise<any> {
            return localVarFp.purchaseIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: any): AxiosPromise<any> {
            return localVarFp.purchaseReceivePayment(id, culture, paymentModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PurchaseApi - object-oriented interface
 * @export
 * @class PurchaseApi
 * @extends {BaseAPI}
 */
export class PurchaseApi extends BaseAPI {
    /**
     * 
     * @summary To change status by the document id and key
     * @param {number} documentId 
     * @param {string} statusKey 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchaseApi
     */
    public purchaseChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: AxiosRequestConfig) {
        return PurchaseApiFp(this.configuration).purchaseChangeStatusByKey(documentId, statusKey, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Create a document with SimpleDocument as the parameter
     * @param {string} culture 
     * @param {SimpleDocument} simpleDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchaseApi
     */
    public purchaseCreate(culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig) {
        return PurchaseApiFp(this.configuration).purchaseCreate(culture, simpleDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Create a document with InlineDocument as the parameter
     * @param {string} culture 
     * @param {InlineDocument} inlineDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchaseApi
     */
    public purchaseCreate2(culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig) {
        return PurchaseApiFp(this.configuration).purchaseCreate2(culture, inlineDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To delete the document given a list of documentids
     * @param {number} id 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchaseApi
     */
    public purchaseDelete(id: number, culture: string, options?: AxiosRequestConfig) {
        return PurchaseApiFp(this.configuration).purchaseDelete(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To get details of a document
     * @param {number} id Sql DocumentId
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchaseApi
     */
    public purchaseDetails(id: number, culture: string, options?: AxiosRequestConfig) {
        return PurchaseApiFp(this.configuration).purchaseDetails(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Update a document with simpleDocument as the parameter
     * @param {number} id 
     * @param {string} culture 
     * @param {SimpleDocument} simpleDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchaseApi
     */
    public purchaseEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig) {
        return PurchaseApiFp(this.configuration).purchaseEdit(id, culture, simpleDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Update a document with inlineDocument as the parameter
     * @param {number} id 
     * @param {string} culture 
     * @param {InlineDocument} inlineDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchaseApi
     */
    public purchaseEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig) {
        return PurchaseApiFp(this.configuration).purchaseEdit2(id, culture, inlineDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To query for documents.
     * @param {string} culture 
     * @param {string} [sortBy] 
     * @param {string} [currentPage] 
     * @param {string} [pageSize] 
     * @param {string} [filter] 
     * @param {string} [searchString] 
     * @param {string} [customDocumentModels] 
     * @param {string} [range] 
     * @param {string} [month] 
     * @param {string} [year] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchaseApi
     */
    public purchaseIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: AxiosRequestConfig) {
        return PurchaseApiFp(this.configuration).purchaseIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Accept payment with the paymentModel
     * @param {number} id 
     * @param {string} culture 
     * @param {PaymentModel} paymentModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchaseApi
     */
    public purchaseReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: AxiosRequestConfig) {
        return PurchaseApiFp(this.configuration).purchaseReceivePayment(id, culture, paymentModel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PurchaseOrderApi - axios parameter creator
 * @export
 */
export const PurchaseOrderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseOrderChangeStatusByKey: async (documentId: number, statusKey: string, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('purchaseOrderChangeStatusByKey', 'documentId', documentId)
            // verify required parameter 'statusKey' is not null or undefined
            assertParamExists('purchaseOrderChangeStatusByKey', 'statusKey', statusKey)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('purchaseOrderChangeStatusByKey', 'culture', culture)
            const localVarPath = `/{culture}/purchase-orders/{documentId}/status-key/{statusKey}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"statusKey"}}`, encodeURIComponent(String(statusKey)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseOrderCreate: async (culture: string, simpleDocument: SimpleDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('purchaseOrderCreate', 'culture', culture)
            // verify required parameter 'simpleDocument' is not null or undefined
            assertParamExists('purchaseOrderCreate', 'simpleDocument', simpleDocument)
            const localVarPath = `/{culture}/purchase-orders/simple-document`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(simpleDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseOrderCreate2: async (culture: string, inlineDocument: InlineDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('purchaseOrderCreate2', 'culture', culture)
            // verify required parameter 'inlineDocument' is not null or undefined
            assertParamExists('purchaseOrderCreate2', 'inlineDocument', inlineDocument)
            const localVarPath = `/{culture}/purchase-orders/inline-document`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseOrderDelete: async (id: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('purchaseOrderDelete', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('purchaseOrderDelete', 'culture', culture)
            const localVarPath = `/{culture}/purchase-orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseOrderDetails: async (id: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('purchaseOrderDetails', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('purchaseOrderDetails', 'culture', culture)
            const localVarPath = `/{culture}/purchase-orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseOrderEdit: async (id: number, culture: string, simpleDocument: SimpleDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('purchaseOrderEdit', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('purchaseOrderEdit', 'culture', culture)
            // verify required parameter 'simpleDocument' is not null or undefined
            assertParamExists('purchaseOrderEdit', 'simpleDocument', simpleDocument)
            const localVarPath = `/{culture}/purchase-orders/simple-document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(simpleDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseOrderEdit2: async (id: number, culture: string, inlineDocument: InlineDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('purchaseOrderEdit2', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('purchaseOrderEdit2', 'culture', culture)
            // verify required parameter 'inlineDocument' is not null or undefined
            assertParamExists('purchaseOrderEdit2', 'inlineDocument', inlineDocument)
            const localVarPath = `/{culture}/purchase-orders/inline-document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseOrderIndex: async (culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('purchaseOrderIndex', 'culture', culture)
            const localVarPath = `/{culture}/purchase-orders`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sortBy !== undefined) {
                localVarQueryParameter['SortBy'] = sortBy;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['CurrentPage'] = currentPage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (filter !== undefined) {
                localVarQueryParameter['Filter'] = filter;
            }

            if (searchString !== undefined) {
                localVarQueryParameter['SearchString'] = searchString;
            }

            if (customDocumentModels !== undefined) {
                localVarQueryParameter['CustomDocumentModels'] = customDocumentModels;
            }

            if (range !== undefined) {
                localVarQueryParameter['Range'] = range;
            }

            if (month !== undefined) {
                localVarQueryParameter['Month'] = month;
            }

            if (year !== undefined) {
                localVarQueryParameter['Year'] = year;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['StartDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['EndDate'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseOrderReceivePayment: async (id: number, culture: string, paymentModel: PaymentModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('purchaseOrderReceivePayment', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('purchaseOrderReceivePayment', 'culture', culture)
            // verify required parameter 'paymentModel' is not null or undefined
            assertParamExists('purchaseOrderReceivePayment', 'paymentModel', paymentModel)
            const localVarPath = `/{culture}/purchase-orders/{id}/payments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PurchaseOrderApi - functional programming interface
 * @export
 */
export const PurchaseOrderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PurchaseOrderApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchaseOrderChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseOrderChangeStatusByKey(documentId, statusKey, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchaseOrderCreate(culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageSent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseOrderCreate(culture, simpleDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchaseOrderCreate2(culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageSent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseOrderCreate2(culture, inlineDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchaseOrderDelete(id: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseOrderDelete(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchaseOrderDetails(id: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseOrderDetails(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchaseOrderEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseOrderEdit(id, culture, simpleDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchaseOrderEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseOrderEdit2(id, culture, inlineDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchaseOrderIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseOrderIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchaseOrderReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseOrderReceivePayment(id, culture, paymentModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PurchaseOrderApi - factory interface
 * @export
 */
export const PurchaseOrderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PurchaseOrderApiFp(configuration)
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseOrderChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.purchaseOrderChangeStatusByKey(documentId, statusKey, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseOrderCreate(culture: string, simpleDocument: SimpleDocument, options?: any): AxiosPromise<MessageSent> {
            return localVarFp.purchaseOrderCreate(culture, simpleDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseOrderCreate2(culture: string, inlineDocument: InlineDocument, options?: any): AxiosPromise<MessageSent> {
            return localVarFp.purchaseOrderCreate2(culture, inlineDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseOrderDelete(id: number, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.purchaseOrderDelete(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseOrderDetails(id: number, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.purchaseOrderDetails(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseOrderEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: any): AxiosPromise<any> {
            return localVarFp.purchaseOrderEdit(id, culture, simpleDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseOrderEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: any): AxiosPromise<any> {
            return localVarFp.purchaseOrderEdit2(id, culture, inlineDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseOrderIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: any): AxiosPromise<any> {
            return localVarFp.purchaseOrderIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseOrderReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: any): AxiosPromise<any> {
            return localVarFp.purchaseOrderReceivePayment(id, culture, paymentModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PurchaseOrderApi - object-oriented interface
 * @export
 * @class PurchaseOrderApi
 * @extends {BaseAPI}
 */
export class PurchaseOrderApi extends BaseAPI {
    /**
     * 
     * @summary To change status by the document id and key
     * @param {number} documentId 
     * @param {string} statusKey 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchaseOrderApi
     */
    public purchaseOrderChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: AxiosRequestConfig) {
        return PurchaseOrderApiFp(this.configuration).purchaseOrderChangeStatusByKey(documentId, statusKey, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Create a document with SimpleDocument as the parameter
     * @param {string} culture 
     * @param {SimpleDocument} simpleDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchaseOrderApi
     */
    public purchaseOrderCreate(culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig) {
        return PurchaseOrderApiFp(this.configuration).purchaseOrderCreate(culture, simpleDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Create a document with InlineDocument as the parameter
     * @param {string} culture 
     * @param {InlineDocument} inlineDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchaseOrderApi
     */
    public purchaseOrderCreate2(culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig) {
        return PurchaseOrderApiFp(this.configuration).purchaseOrderCreate2(culture, inlineDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To delete the document given a list of documentids
     * @param {number} id 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchaseOrderApi
     */
    public purchaseOrderDelete(id: number, culture: string, options?: AxiosRequestConfig) {
        return PurchaseOrderApiFp(this.configuration).purchaseOrderDelete(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To get details of a document
     * @param {number} id Sql DocumentId
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchaseOrderApi
     */
    public purchaseOrderDetails(id: number, culture: string, options?: AxiosRequestConfig) {
        return PurchaseOrderApiFp(this.configuration).purchaseOrderDetails(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Update a document with simpleDocument as the parameter
     * @param {number} id 
     * @param {string} culture 
     * @param {SimpleDocument} simpleDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchaseOrderApi
     */
    public purchaseOrderEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig) {
        return PurchaseOrderApiFp(this.configuration).purchaseOrderEdit(id, culture, simpleDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Update a document with inlineDocument as the parameter
     * @param {number} id 
     * @param {string} culture 
     * @param {InlineDocument} inlineDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchaseOrderApi
     */
    public purchaseOrderEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig) {
        return PurchaseOrderApiFp(this.configuration).purchaseOrderEdit2(id, culture, inlineDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To query for documents.
     * @param {string} culture 
     * @param {string} [sortBy] 
     * @param {string} [currentPage] 
     * @param {string} [pageSize] 
     * @param {string} [filter] 
     * @param {string} [searchString] 
     * @param {string} [customDocumentModels] 
     * @param {string} [range] 
     * @param {string} [month] 
     * @param {string} [year] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchaseOrderApi
     */
    public purchaseOrderIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: AxiosRequestConfig) {
        return PurchaseOrderApiFp(this.configuration).purchaseOrderIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Accept payment with the paymentModel
     * @param {number} id 
     * @param {string} culture 
     * @param {PaymentModel} paymentModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchaseOrderApi
     */
    public purchaseOrderReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: AxiosRequestConfig) {
        return PurchaseOrderApiFp(this.configuration).purchaseOrderReceivePayment(id, culture, paymentModel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QuotationApi - axios parameter creator
 * @export
 */
export const QuotationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotationChangeStatusByKey: async (documentId: number, statusKey: string, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('quotationChangeStatusByKey', 'documentId', documentId)
            // verify required parameter 'statusKey' is not null or undefined
            assertParamExists('quotationChangeStatusByKey', 'statusKey', statusKey)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('quotationChangeStatusByKey', 'culture', culture)
            const localVarPath = `/{culture}/quotations/{documentId}/status-key/{statusKey}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"statusKey"}}`, encodeURIComponent(String(statusKey)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotationCreate: async (culture: string, simpleDocument: SimpleDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('quotationCreate', 'culture', culture)
            // verify required parameter 'simpleDocument' is not null or undefined
            assertParamExists('quotationCreate', 'simpleDocument', simpleDocument)
            const localVarPath = `/{culture}/quotations/simple-document`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(simpleDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotationCreate2: async (culture: string, inlineDocument: InlineDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('quotationCreate2', 'culture', culture)
            // verify required parameter 'inlineDocument' is not null or undefined
            assertParamExists('quotationCreate2', 'inlineDocument', inlineDocument)
            const localVarPath = `/{culture}/quotations/inline-document`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotationCreatePartialManualPayall: async (id: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('quotationCreatePartialManualPayall', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('quotationCreatePartialManualPayall', 'culture', culture)
            const localVarPath = `/{culture}/quotations/{id}/partial-manual-payall`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotationDelete: async (id: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('quotationDelete', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('quotationDelete', 'culture', culture)
            const localVarPath = `/{culture}/quotations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotationDetails: async (id: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('quotationDetails', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('quotationDetails', 'culture', culture)
            const localVarPath = `/{culture}/quotations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotationEdit: async (id: number, culture: string, simpleDocument: SimpleDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('quotationEdit', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('quotationEdit', 'culture', culture)
            // verify required parameter 'simpleDocument' is not null or undefined
            assertParamExists('quotationEdit', 'simpleDocument', simpleDocument)
            const localVarPath = `/{culture}/quotations/simple-document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(simpleDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotationEdit2: async (id: number, culture: string, inlineDocument: InlineDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('quotationEdit2', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('quotationEdit2', 'culture', culture)
            // verify required parameter 'inlineDocument' is not null or undefined
            assertParamExists('quotationEdit2', 'inlineDocument', inlineDocument)
            const localVarPath = `/{culture}/quotations/inline-document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotationIndex: async (culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('quotationIndex', 'culture', culture)
            const localVarPath = `/{culture}/quotations`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sortBy !== undefined) {
                localVarQueryParameter['SortBy'] = sortBy;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['CurrentPage'] = currentPage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (filter !== undefined) {
                localVarQueryParameter['Filter'] = filter;
            }

            if (searchString !== undefined) {
                localVarQueryParameter['SearchString'] = searchString;
            }

            if (customDocumentModels !== undefined) {
                localVarQueryParameter['CustomDocumentModels'] = customDocumentModels;
            }

            if (range !== undefined) {
                localVarQueryParameter['Range'] = range;
            }

            if (month !== undefined) {
                localVarQueryParameter['Month'] = month;
            }

            if (year !== undefined) {
                localVarQueryParameter['Year'] = year;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['StartDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['EndDate'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotationPartialManualCancel: async (id: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('quotationPartialManualCancel', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('quotationPartialManualCancel', 'culture', culture)
            const localVarPath = `/{culture}/quotations/{id}/partial-manual-cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotationReceivePayment: async (id: number, culture: string, paymentModel: PaymentModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('quotationReceivePayment', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('quotationReceivePayment', 'culture', culture)
            // verify required parameter 'paymentModel' is not null or undefined
            assertParamExists('quotationReceivePayment', 'paymentModel', paymentModel)
            const localVarPath = `/{culture}/quotations/{id}/payments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuotationApi - functional programming interface
 * @export
 */
export const QuotationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QuotationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quotationChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quotationChangeStatusByKey(documentId, statusKey, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quotationCreate(culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageSent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quotationCreate(culture, simpleDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quotationCreate2(culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageSent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quotationCreate2(culture, inlineDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quotationCreatePartialManualPayall(id: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quotationCreatePartialManualPayall(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quotationDelete(id: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quotationDelete(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quotationDetails(id: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quotationDetails(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quotationEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quotationEdit(id, culture, simpleDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quotationEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quotationEdit2(id, culture, inlineDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quotationIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quotationIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quotationPartialManualCancel(id: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quotationPartialManualCancel(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quotationReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quotationReceivePayment(id, culture, paymentModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QuotationApi - factory interface
 * @export
 */
export const QuotationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QuotationApiFp(configuration)
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotationChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.quotationChangeStatusByKey(documentId, statusKey, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotationCreate(culture: string, simpleDocument: SimpleDocument, options?: any): AxiosPromise<MessageSent> {
            return localVarFp.quotationCreate(culture, simpleDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotationCreate2(culture: string, inlineDocument: InlineDocument, options?: any): AxiosPromise<MessageSent> {
            return localVarFp.quotationCreate2(culture, inlineDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotationCreatePartialManualPayall(id: number, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.quotationCreatePartialManualPayall(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotationDelete(id: number, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.quotationDelete(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotationDetails(id: number, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.quotationDetails(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotationEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: any): AxiosPromise<any> {
            return localVarFp.quotationEdit(id, culture, simpleDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotationEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: any): AxiosPromise<any> {
            return localVarFp.quotationEdit2(id, culture, inlineDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotationIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: any): AxiosPromise<any> {
            return localVarFp.quotationIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotationPartialManualCancel(id: number, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.quotationPartialManualCancel(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotationReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: any): AxiosPromise<any> {
            return localVarFp.quotationReceivePayment(id, culture, paymentModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QuotationApi - object-oriented interface
 * @export
 * @class QuotationApi
 * @extends {BaseAPI}
 */
export class QuotationApi extends BaseAPI {
    /**
     * 
     * @summary To change status by the document id and key
     * @param {number} documentId 
     * @param {string} statusKey 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotationApi
     */
    public quotationChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: AxiosRequestConfig) {
        return QuotationApiFp(this.configuration).quotationChangeStatusByKey(documentId, statusKey, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Create a document with SimpleDocument as the parameter
     * @param {string} culture 
     * @param {SimpleDocument} simpleDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotationApi
     */
    public quotationCreate(culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig) {
        return QuotationApiFp(this.configuration).quotationCreate(culture, simpleDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Create a document with InlineDocument as the parameter
     * @param {string} culture 
     * @param {InlineDocument} inlineDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotationApi
     */
    public quotationCreate2(culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig) {
        return QuotationApiFp(this.configuration).quotationCreate2(culture, inlineDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotationApi
     */
    public quotationCreatePartialManualPayall(id: number, culture: string, options?: AxiosRequestConfig) {
        return QuotationApiFp(this.configuration).quotationCreatePartialManualPayall(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To delete the document given a list of documentids
     * @param {number} id 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotationApi
     */
    public quotationDelete(id: number, culture: string, options?: AxiosRequestConfig) {
        return QuotationApiFp(this.configuration).quotationDelete(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To get details of a document
     * @param {number} id Sql DocumentId
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotationApi
     */
    public quotationDetails(id: number, culture: string, options?: AxiosRequestConfig) {
        return QuotationApiFp(this.configuration).quotationDetails(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Update a document with simpleDocument as the parameter
     * @param {number} id 
     * @param {string} culture 
     * @param {SimpleDocument} simpleDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotationApi
     */
    public quotationEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig) {
        return QuotationApiFp(this.configuration).quotationEdit(id, culture, simpleDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Update a document with inlineDocument as the parameter
     * @param {number} id 
     * @param {string} culture 
     * @param {InlineDocument} inlineDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotationApi
     */
    public quotationEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig) {
        return QuotationApiFp(this.configuration).quotationEdit2(id, culture, inlineDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To query for documents.
     * @param {string} culture 
     * @param {string} [sortBy] 
     * @param {string} [currentPage] 
     * @param {string} [pageSize] 
     * @param {string} [filter] 
     * @param {string} [searchString] 
     * @param {string} [customDocumentModels] 
     * @param {string} [range] 
     * @param {string} [month] 
     * @param {string} [year] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotationApi
     */
    public quotationIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: AxiosRequestConfig) {
        return QuotationApiFp(this.configuration).quotationIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotationApi
     */
    public quotationPartialManualCancel(id: number, culture: string, options?: AxiosRequestConfig) {
        return QuotationApiFp(this.configuration).quotationPartialManualCancel(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Accept payment with the paymentModel
     * @param {number} id 
     * @param {string} culture 
     * @param {PaymentModel} paymentModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotationApi
     */
    public quotationReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: AxiosRequestConfig) {
        return QuotationApiFp(this.configuration).quotationReceivePayment(id, culture, paymentModel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReceiptApi - axios parameter creator
 * @export
 */
export const ReceiptApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiptChangeStatusByKey: async (documentId: number, statusKey: string, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('receiptChangeStatusByKey', 'documentId', documentId)
            // verify required parameter 'statusKey' is not null or undefined
            assertParamExists('receiptChangeStatusByKey', 'statusKey', statusKey)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('receiptChangeStatusByKey', 'culture', culture)
            const localVarPath = `/{culture}/receipts/{documentId}/status-key/{statusKey}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"statusKey"}}`, encodeURIComponent(String(statusKey)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiptCreate: async (culture: string, simpleDocument: SimpleDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('receiptCreate', 'culture', culture)
            // verify required parameter 'simpleDocument' is not null or undefined
            assertParamExists('receiptCreate', 'simpleDocument', simpleDocument)
            const localVarPath = `/{culture}/receipts/simple-document`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(simpleDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiptCreate2: async (culture: string, inlineDocument: InlineDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('receiptCreate2', 'culture', culture)
            // verify required parameter 'inlineDocument' is not null or undefined
            assertParamExists('receiptCreate2', 'inlineDocument', inlineDocument)
            const localVarPath = `/{culture}/receipts/inline-document`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiptDelete: async (id: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('receiptDelete', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('receiptDelete', 'culture', culture)
            const localVarPath = `/{culture}/receipts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiptDetails: async (id: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('receiptDetails', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('receiptDetails', 'culture', culture)
            const localVarPath = `/{culture}/receipts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiptEdit: async (id: number, culture: string, simpleDocument: SimpleDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('receiptEdit', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('receiptEdit', 'culture', culture)
            // verify required parameter 'simpleDocument' is not null or undefined
            assertParamExists('receiptEdit', 'simpleDocument', simpleDocument)
            const localVarPath = `/{culture}/receipts/simple-document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(simpleDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiptEdit2: async (id: number, culture: string, inlineDocument: InlineDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('receiptEdit2', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('receiptEdit2', 'culture', culture)
            // verify required parameter 'inlineDocument' is not null or undefined
            assertParamExists('receiptEdit2', 'inlineDocument', inlineDocument)
            const localVarPath = `/{culture}/receipts/inline-document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiptGetBusinessCategories: async (culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('receiptGetBusinessCategories', 'culture', culture)
            const localVarPath = `/{culture}/receipts/categories/business`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiptGetChartOfAccounts: async (culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('receiptGetChartOfAccounts', 'culture', culture)
            const localVarPath = `/{culture}/receipts/categories/accounting`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiptIndex: async (culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('receiptIndex', 'culture', culture)
            const localVarPath = `/{culture}/receipts`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sortBy !== undefined) {
                localVarQueryParameter['SortBy'] = sortBy;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['CurrentPage'] = currentPage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (filter !== undefined) {
                localVarQueryParameter['Filter'] = filter;
            }

            if (searchString !== undefined) {
                localVarQueryParameter['SearchString'] = searchString;
            }

            if (customDocumentModels !== undefined) {
                localVarQueryParameter['CustomDocumentModels'] = customDocumentModels;
            }

            if (range !== undefined) {
                localVarQueryParameter['Range'] = range;
            }

            if (month !== undefined) {
                localVarQueryParameter['Month'] = month;
            }

            if (year !== undefined) {
                localVarQueryParameter['Year'] = year;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['StartDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['EndDate'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiptReceivePayment: async (id: number, culture: string, paymentModel: PaymentModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('receiptReceivePayment', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('receiptReceivePayment', 'culture', culture)
            // verify required parameter 'paymentModel' is not null or undefined
            assertParamExists('receiptReceivePayment', 'paymentModel', paymentModel)
            const localVarPath = `/{culture}/receipts/{id}/payments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReceiptApi - functional programming interface
 * @export
 */
export const ReceiptApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReceiptApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async receiptChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.receiptChangeStatusByKey(documentId, statusKey, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async receiptCreate(culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageSent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.receiptCreate(culture, simpleDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async receiptCreate2(culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageSent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.receiptCreate2(culture, inlineDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async receiptDelete(id: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.receiptDelete(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async receiptDetails(id: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.receiptDetails(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async receiptEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.receiptEdit(id, culture, simpleDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async receiptEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.receiptEdit2(id, culture, inlineDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async receiptGetBusinessCategories(culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.receiptGetBusinessCategories(culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async receiptGetChartOfAccounts(culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.receiptGetChartOfAccounts(culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async receiptIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.receiptIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async receiptReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.receiptReceivePayment(id, culture, paymentModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReceiptApi - factory interface
 * @export
 */
export const ReceiptApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReceiptApiFp(configuration)
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiptChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.receiptChangeStatusByKey(documentId, statusKey, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiptCreate(culture: string, simpleDocument: SimpleDocument, options?: any): AxiosPromise<MessageSent> {
            return localVarFp.receiptCreate(culture, simpleDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiptCreate2(culture: string, inlineDocument: InlineDocument, options?: any): AxiosPromise<MessageSent> {
            return localVarFp.receiptCreate2(culture, inlineDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiptDelete(id: number, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.receiptDelete(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiptDetails(id: number, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.receiptDetails(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiptEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: any): AxiosPromise<any> {
            return localVarFp.receiptEdit(id, culture, simpleDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiptEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: any): AxiosPromise<any> {
            return localVarFp.receiptEdit2(id, culture, inlineDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiptGetBusinessCategories(culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.receiptGetBusinessCategories(culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiptGetChartOfAccounts(culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.receiptGetChartOfAccounts(culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiptIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: any): AxiosPromise<any> {
            return localVarFp.receiptIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiptReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: any): AxiosPromise<any> {
            return localVarFp.receiptReceivePayment(id, culture, paymentModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReceiptApi - object-oriented interface
 * @export
 * @class ReceiptApi
 * @extends {BaseAPI}
 */
export class ReceiptApi extends BaseAPI {
    /**
     * 
     * @summary To change status by the document id and key
     * @param {number} documentId 
     * @param {string} statusKey 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceiptApi
     */
    public receiptChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: AxiosRequestConfig) {
        return ReceiptApiFp(this.configuration).receiptChangeStatusByKey(documentId, statusKey, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Create a document with SimpleDocument as the parameter
     * @param {string} culture 
     * @param {SimpleDocument} simpleDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceiptApi
     */
    public receiptCreate(culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig) {
        return ReceiptApiFp(this.configuration).receiptCreate(culture, simpleDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Create a document with InlineDocument as the parameter
     * @param {string} culture 
     * @param {InlineDocument} inlineDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceiptApi
     */
    public receiptCreate2(culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig) {
        return ReceiptApiFp(this.configuration).receiptCreate2(culture, inlineDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To delete the document given a list of documentids
     * @param {number} id 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceiptApi
     */
    public receiptDelete(id: number, culture: string, options?: AxiosRequestConfig) {
        return ReceiptApiFp(this.configuration).receiptDelete(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To get details of a document
     * @param {number} id Sql DocumentId
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceiptApi
     */
    public receiptDetails(id: number, culture: string, options?: AxiosRequestConfig) {
        return ReceiptApiFp(this.configuration).receiptDetails(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Update a document with simpleDocument as the parameter
     * @param {number} id 
     * @param {string} culture 
     * @param {SimpleDocument} simpleDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceiptApi
     */
    public receiptEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig) {
        return ReceiptApiFp(this.configuration).receiptEdit(id, culture, simpleDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Update a document with inlineDocument as the parameter
     * @param {number} id 
     * @param {string} culture 
     * @param {InlineDocument} inlineDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceiptApi
     */
    public receiptEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig) {
        return ReceiptApiFp(this.configuration).receiptEdit2(id, culture, inlineDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceiptApi
     */
    public receiptGetBusinessCategories(culture: string, options?: AxiosRequestConfig) {
        return ReceiptApiFp(this.configuration).receiptGetBusinessCategories(culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceiptApi
     */
    public receiptGetChartOfAccounts(culture: string, options?: AxiosRequestConfig) {
        return ReceiptApiFp(this.configuration).receiptGetChartOfAccounts(culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To query for documents.
     * @param {string} culture 
     * @param {string} [sortBy] 
     * @param {string} [currentPage] 
     * @param {string} [pageSize] 
     * @param {string} [filter] 
     * @param {string} [searchString] 
     * @param {string} [customDocumentModels] 
     * @param {string} [range] 
     * @param {string} [month] 
     * @param {string} [year] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceiptApi
     */
    public receiptIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: AxiosRequestConfig) {
        return ReceiptApiFp(this.configuration).receiptIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Accept payment with the paymentModel
     * @param {number} id 
     * @param {string} culture 
     * @param {PaymentModel} paymentModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceiptApi
     */
    public receiptReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: AxiosRequestConfig) {
        return ReceiptApiFp(this.configuration).receiptReceivePayment(id, culture, paymentModel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReceivableInvoiceApi - axios parameter creator
 * @export
 */
export const ReceivableInvoiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receivableInvoiceChangeStatusByKey: async (documentId: number, statusKey: string, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('receivableInvoiceChangeStatusByKey', 'documentId', documentId)
            // verify required parameter 'statusKey' is not null or undefined
            assertParamExists('receivableInvoiceChangeStatusByKey', 'statusKey', statusKey)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('receivableInvoiceChangeStatusByKey', 'culture', culture)
            const localVarPath = `/{culture}/receivable-invoices/{documentId}/status-key/{statusKey}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"statusKey"}}`, encodeURIComponent(String(statusKey)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receivableInvoiceCreate: async (culture: string, simpleDocument: SimpleDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('receivableInvoiceCreate', 'culture', culture)
            // verify required parameter 'simpleDocument' is not null or undefined
            assertParamExists('receivableInvoiceCreate', 'simpleDocument', simpleDocument)
            const localVarPath = `/{culture}/receivable-invoices/simple-document`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(simpleDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receivableInvoiceCreate2: async (culture: string, inlineDocument: InlineDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('receivableInvoiceCreate2', 'culture', culture)
            // verify required parameter 'inlineDocument' is not null or undefined
            assertParamExists('receivableInvoiceCreate2', 'inlineDocument', inlineDocument)
            const localVarPath = `/{culture}/receivable-invoices/inline-document`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receivableInvoiceDelete: async (id: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('receivableInvoiceDelete', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('receivableInvoiceDelete', 'culture', culture)
            const localVarPath = `/{culture}/receivable-invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receivableInvoiceDetails: async (id: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('receivableInvoiceDetails', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('receivableInvoiceDetails', 'culture', culture)
            const localVarPath = `/{culture}/receivable-invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receivableInvoiceEdit: async (id: number, culture: string, simpleDocument: SimpleDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('receivableInvoiceEdit', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('receivableInvoiceEdit', 'culture', culture)
            // verify required parameter 'simpleDocument' is not null or undefined
            assertParamExists('receivableInvoiceEdit', 'simpleDocument', simpleDocument)
            const localVarPath = `/{culture}/receivable-invoices/simple-document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(simpleDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receivableInvoiceEdit2: async (id: number, culture: string, inlineDocument: InlineDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('receivableInvoiceEdit2', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('receivableInvoiceEdit2', 'culture', culture)
            // verify required parameter 'inlineDocument' is not null or undefined
            assertParamExists('receivableInvoiceEdit2', 'inlineDocument', inlineDocument)
            const localVarPath = `/{culture}/receivable-invoices/inline-document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receivableInvoiceIndex: async (culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('receivableInvoiceIndex', 'culture', culture)
            const localVarPath = `/{culture}/receivable-invoices`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sortBy !== undefined) {
                localVarQueryParameter['SortBy'] = sortBy;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['CurrentPage'] = currentPage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (filter !== undefined) {
                localVarQueryParameter['Filter'] = filter;
            }

            if (searchString !== undefined) {
                localVarQueryParameter['SearchString'] = searchString;
            }

            if (customDocumentModels !== undefined) {
                localVarQueryParameter['CustomDocumentModels'] = customDocumentModels;
            }

            if (range !== undefined) {
                localVarQueryParameter['Range'] = range;
            }

            if (month !== undefined) {
                localVarQueryParameter['Month'] = month;
            }

            if (year !== undefined) {
                localVarQueryParameter['Year'] = year;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['StartDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['EndDate'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receivableInvoiceReceivePayment: async (id: number, culture: string, paymentModel: PaymentModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('receivableInvoiceReceivePayment', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('receivableInvoiceReceivePayment', 'culture', culture)
            // verify required parameter 'paymentModel' is not null or undefined
            assertParamExists('receivableInvoiceReceivePayment', 'paymentModel', paymentModel)
            const localVarPath = `/{culture}/receivable-invoices/{id}/payments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReceivableInvoiceApi - functional programming interface
 * @export
 */
export const ReceivableInvoiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReceivableInvoiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async receivableInvoiceChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.receivableInvoiceChangeStatusByKey(documentId, statusKey, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async receivableInvoiceCreate(culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageSent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.receivableInvoiceCreate(culture, simpleDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async receivableInvoiceCreate2(culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageSent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.receivableInvoiceCreate2(culture, inlineDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async receivableInvoiceDelete(id: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.receivableInvoiceDelete(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async receivableInvoiceDetails(id: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.receivableInvoiceDetails(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async receivableInvoiceEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.receivableInvoiceEdit(id, culture, simpleDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async receivableInvoiceEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.receivableInvoiceEdit2(id, culture, inlineDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async receivableInvoiceIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.receivableInvoiceIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async receivableInvoiceReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.receivableInvoiceReceivePayment(id, culture, paymentModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReceivableInvoiceApi - factory interface
 * @export
 */
export const ReceivableInvoiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReceivableInvoiceApiFp(configuration)
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receivableInvoiceChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.receivableInvoiceChangeStatusByKey(documentId, statusKey, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receivableInvoiceCreate(culture: string, simpleDocument: SimpleDocument, options?: any): AxiosPromise<MessageSent> {
            return localVarFp.receivableInvoiceCreate(culture, simpleDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receivableInvoiceCreate2(culture: string, inlineDocument: InlineDocument, options?: any): AxiosPromise<MessageSent> {
            return localVarFp.receivableInvoiceCreate2(culture, inlineDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receivableInvoiceDelete(id: number, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.receivableInvoiceDelete(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receivableInvoiceDetails(id: number, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.receivableInvoiceDetails(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receivableInvoiceEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: any): AxiosPromise<any> {
            return localVarFp.receivableInvoiceEdit(id, culture, simpleDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receivableInvoiceEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: any): AxiosPromise<any> {
            return localVarFp.receivableInvoiceEdit2(id, culture, inlineDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receivableInvoiceIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: any): AxiosPromise<any> {
            return localVarFp.receivableInvoiceIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receivableInvoiceReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: any): AxiosPromise<any> {
            return localVarFp.receivableInvoiceReceivePayment(id, culture, paymentModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReceivableInvoiceApi - object-oriented interface
 * @export
 * @class ReceivableInvoiceApi
 * @extends {BaseAPI}
 */
export class ReceivableInvoiceApi extends BaseAPI {
    /**
     * 
     * @summary To change status by the document id and key
     * @param {number} documentId 
     * @param {string} statusKey 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceivableInvoiceApi
     */
    public receivableInvoiceChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: AxiosRequestConfig) {
        return ReceivableInvoiceApiFp(this.configuration).receivableInvoiceChangeStatusByKey(documentId, statusKey, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Create a document with SimpleDocument as the parameter
     * @param {string} culture 
     * @param {SimpleDocument} simpleDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceivableInvoiceApi
     */
    public receivableInvoiceCreate(culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig) {
        return ReceivableInvoiceApiFp(this.configuration).receivableInvoiceCreate(culture, simpleDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Create a document with InlineDocument as the parameter
     * @param {string} culture 
     * @param {InlineDocument} inlineDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceivableInvoiceApi
     */
    public receivableInvoiceCreate2(culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig) {
        return ReceivableInvoiceApiFp(this.configuration).receivableInvoiceCreate2(culture, inlineDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To delete the document given a list of documentids
     * @param {number} id 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceivableInvoiceApi
     */
    public receivableInvoiceDelete(id: number, culture: string, options?: AxiosRequestConfig) {
        return ReceivableInvoiceApiFp(this.configuration).receivableInvoiceDelete(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To get details of a document
     * @param {number} id Sql DocumentId
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceivableInvoiceApi
     */
    public receivableInvoiceDetails(id: number, culture: string, options?: AxiosRequestConfig) {
        return ReceivableInvoiceApiFp(this.configuration).receivableInvoiceDetails(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Update a document with simpleDocument as the parameter
     * @param {number} id 
     * @param {string} culture 
     * @param {SimpleDocument} simpleDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceivableInvoiceApi
     */
    public receivableInvoiceEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig) {
        return ReceivableInvoiceApiFp(this.configuration).receivableInvoiceEdit(id, culture, simpleDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Update a document with inlineDocument as the parameter
     * @param {number} id 
     * @param {string} culture 
     * @param {InlineDocument} inlineDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceivableInvoiceApi
     */
    public receivableInvoiceEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig) {
        return ReceivableInvoiceApiFp(this.configuration).receivableInvoiceEdit2(id, culture, inlineDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To query for documents.
     * @param {string} culture 
     * @param {string} [sortBy] 
     * @param {string} [currentPage] 
     * @param {string} [pageSize] 
     * @param {string} [filter] 
     * @param {string} [searchString] 
     * @param {string} [customDocumentModels] 
     * @param {string} [range] 
     * @param {string} [month] 
     * @param {string} [year] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceivableInvoiceApi
     */
    public receivableInvoiceIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: AxiosRequestConfig) {
        return ReceivableInvoiceApiFp(this.configuration).receivableInvoiceIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Accept payment with the paymentModel
     * @param {number} id 
     * @param {string} culture 
     * @param {PaymentModel} paymentModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceivableInvoiceApi
     */
    public receivableInvoiceReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: AxiosRequestConfig) {
        return ReceivableInvoiceApiFp(this.configuration).receivableInvoiceReceivePayment(id, culture, paymentModel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TaxInvoiceApi - axios parameter creator
 * @export
 */
export const TaxInvoiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxInvoiceChangeStatusByKey: async (documentId: number, statusKey: string, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('taxInvoiceChangeStatusByKey', 'documentId', documentId)
            // verify required parameter 'statusKey' is not null or undefined
            assertParamExists('taxInvoiceChangeStatusByKey', 'statusKey', statusKey)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('taxInvoiceChangeStatusByKey', 'culture', culture)
            const localVarPath = `/{culture}/tax-invoices/{documentId}/status-key/{statusKey}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"statusKey"}}`, encodeURIComponent(String(statusKey)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxInvoiceCreate: async (culture: string, simpleDocument: SimpleDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('taxInvoiceCreate', 'culture', culture)
            // verify required parameter 'simpleDocument' is not null or undefined
            assertParamExists('taxInvoiceCreate', 'simpleDocument', simpleDocument)
            const localVarPath = `/{culture}/tax-invoices/simple-document`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(simpleDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxInvoiceCreate2: async (culture: string, inlineDocument: InlineDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('taxInvoiceCreate2', 'culture', culture)
            // verify required parameter 'inlineDocument' is not null or undefined
            assertParamExists('taxInvoiceCreate2', 'inlineDocument', inlineDocument)
            const localVarPath = `/{culture}/tax-invoices/inline-document`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxInvoiceDelete: async (id: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('taxInvoiceDelete', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('taxInvoiceDelete', 'culture', culture)
            const localVarPath = `/{culture}/tax-invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxInvoiceDetails: async (id: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('taxInvoiceDetails', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('taxInvoiceDetails', 'culture', culture)
            const localVarPath = `/{culture}/tax-invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxInvoiceEdit: async (id: number, culture: string, simpleDocument: SimpleDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('taxInvoiceEdit', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('taxInvoiceEdit', 'culture', culture)
            // verify required parameter 'simpleDocument' is not null or undefined
            assertParamExists('taxInvoiceEdit', 'simpleDocument', simpleDocument)
            const localVarPath = `/{culture}/tax-invoices/simple-document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(simpleDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxInvoiceEdit2: async (id: number, culture: string, inlineDocument: InlineDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('taxInvoiceEdit2', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('taxInvoiceEdit2', 'culture', culture)
            // verify required parameter 'inlineDocument' is not null or undefined
            assertParamExists('taxInvoiceEdit2', 'inlineDocument', inlineDocument)
            const localVarPath = `/{culture}/tax-invoices/inline-document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} culture 
         * @param {string} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxInvoiceGetCumulativeDocumentReferenceList: async (culture: string, ids?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('taxInvoiceGetCumulativeDocumentReferenceList', 'culture', culture)
            const localVarPath = `/{culture}/tax-invoices/cumulative-references`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxInvoiceIndex: async (culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('taxInvoiceIndex', 'culture', culture)
            const localVarPath = `/{culture}/tax-invoices`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sortBy !== undefined) {
                localVarQueryParameter['SortBy'] = sortBy;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['CurrentPage'] = currentPage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (filter !== undefined) {
                localVarQueryParameter['Filter'] = filter;
            }

            if (searchString !== undefined) {
                localVarQueryParameter['SearchString'] = searchString;
            }

            if (customDocumentModels !== undefined) {
                localVarQueryParameter['CustomDocumentModels'] = customDocumentModels;
            }

            if (range !== undefined) {
                localVarQueryParameter['Range'] = range;
            }

            if (month !== undefined) {
                localVarQueryParameter['Month'] = month;
            }

            if (year !== undefined) {
                localVarQueryParameter['Year'] = year;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['StartDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['EndDate'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxInvoiceReceivePayment: async (id: number, culture: string, paymentModel: PaymentModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('taxInvoiceReceivePayment', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('taxInvoiceReceivePayment', 'culture', culture)
            // verify required parameter 'paymentModel' is not null or undefined
            assertParamExists('taxInvoiceReceivePayment', 'paymentModel', paymentModel)
            const localVarPath = `/{culture}/tax-invoices/{id}/payments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaxInvoiceApi - functional programming interface
 * @export
 */
export const TaxInvoiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaxInvoiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taxInvoiceChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taxInvoiceChangeStatusByKey(documentId, statusKey, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taxInvoiceCreate(culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageSent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taxInvoiceCreate(culture, simpleDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taxInvoiceCreate2(culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageSent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taxInvoiceCreate2(culture, inlineDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taxInvoiceDelete(id: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taxInvoiceDelete(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taxInvoiceDetails(id: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taxInvoiceDetails(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taxInvoiceEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taxInvoiceEdit(id, culture, simpleDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taxInvoiceEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taxInvoiceEdit2(id, culture, inlineDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} culture 
         * @param {string} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taxInvoiceGetCumulativeDocumentReferenceList(culture: string, ids?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taxInvoiceGetCumulativeDocumentReferenceList(culture, ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taxInvoiceIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taxInvoiceIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taxInvoiceReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taxInvoiceReceivePayment(id, culture, paymentModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TaxInvoiceApi - factory interface
 * @export
 */
export const TaxInvoiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaxInvoiceApiFp(configuration)
    return {
        /**
         * 
         * @summary To change status by the document id and key
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxInvoiceChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.taxInvoiceChangeStatusByKey(documentId, statusKey, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Create a document with SimpleDocument as the parameter
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxInvoiceCreate(culture: string, simpleDocument: SimpleDocument, options?: any): AxiosPromise<MessageSent> {
            return localVarFp.taxInvoiceCreate(culture, simpleDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Create a document with InlineDocument as the parameter
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxInvoiceCreate2(culture: string, inlineDocument: InlineDocument, options?: any): AxiosPromise<MessageSent> {
            return localVarFp.taxInvoiceCreate2(culture, inlineDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To delete the document given a list of documentids
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxInvoiceDelete(id: number, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.taxInvoiceDelete(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To get details of a document
         * @param {number} id Sql DocumentId
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxInvoiceDetails(id: number, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.taxInvoiceDetails(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Update a document with simpleDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {SimpleDocument} simpleDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxInvoiceEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: any): AxiosPromise<any> {
            return localVarFp.taxInvoiceEdit(id, culture, simpleDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Update a document with inlineDocument as the parameter
         * @param {number} id 
         * @param {string} culture 
         * @param {InlineDocument} inlineDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxInvoiceEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: any): AxiosPromise<any> {
            return localVarFp.taxInvoiceEdit2(id, culture, inlineDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} culture 
         * @param {string} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxInvoiceGetCumulativeDocumentReferenceList(culture: string, ids?: string, options?: any): AxiosPromise<any> {
            return localVarFp.taxInvoiceGetCumulativeDocumentReferenceList(culture, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To query for documents.
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxInvoiceIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: any): AxiosPromise<any> {
            return localVarFp.taxInvoiceIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To Accept payment with the paymentModel
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxInvoiceReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: any): AxiosPromise<any> {
            return localVarFp.taxInvoiceReceivePayment(id, culture, paymentModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaxInvoiceApi - object-oriented interface
 * @export
 * @class TaxInvoiceApi
 * @extends {BaseAPI}
 */
export class TaxInvoiceApi extends BaseAPI {
    /**
     * 
     * @summary To change status by the document id and key
     * @param {number} documentId 
     * @param {string} statusKey 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxInvoiceApi
     */
    public taxInvoiceChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: AxiosRequestConfig) {
        return TaxInvoiceApiFp(this.configuration).taxInvoiceChangeStatusByKey(documentId, statusKey, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Create a document with SimpleDocument as the parameter
     * @param {string} culture 
     * @param {SimpleDocument} simpleDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxInvoiceApi
     */
    public taxInvoiceCreate(culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig) {
        return TaxInvoiceApiFp(this.configuration).taxInvoiceCreate(culture, simpleDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Create a document with InlineDocument as the parameter
     * @param {string} culture 
     * @param {InlineDocument} inlineDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxInvoiceApi
     */
    public taxInvoiceCreate2(culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig) {
        return TaxInvoiceApiFp(this.configuration).taxInvoiceCreate2(culture, inlineDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To delete the document given a list of documentids
     * @param {number} id 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxInvoiceApi
     */
    public taxInvoiceDelete(id: number, culture: string, options?: AxiosRequestConfig) {
        return TaxInvoiceApiFp(this.configuration).taxInvoiceDelete(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To get details of a document
     * @param {number} id Sql DocumentId
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxInvoiceApi
     */
    public taxInvoiceDetails(id: number, culture: string, options?: AxiosRequestConfig) {
        return TaxInvoiceApiFp(this.configuration).taxInvoiceDetails(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Update a document with simpleDocument as the parameter
     * @param {number} id 
     * @param {string} culture 
     * @param {SimpleDocument} simpleDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxInvoiceApi
     */
    public taxInvoiceEdit(id: number, culture: string, simpleDocument: SimpleDocument, options?: AxiosRequestConfig) {
        return TaxInvoiceApiFp(this.configuration).taxInvoiceEdit(id, culture, simpleDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Update a document with inlineDocument as the parameter
     * @param {number} id 
     * @param {string} culture 
     * @param {InlineDocument} inlineDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxInvoiceApi
     */
    public taxInvoiceEdit2(id: number, culture: string, inlineDocument: InlineDocument, options?: AxiosRequestConfig) {
        return TaxInvoiceApiFp(this.configuration).taxInvoiceEdit2(id, culture, inlineDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} culture 
     * @param {string} [ids] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxInvoiceApi
     */
    public taxInvoiceGetCumulativeDocumentReferenceList(culture: string, ids?: string, options?: AxiosRequestConfig) {
        return TaxInvoiceApiFp(this.configuration).taxInvoiceGetCumulativeDocumentReferenceList(culture, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To query for documents.
     * @param {string} culture 
     * @param {string} [sortBy] 
     * @param {string} [currentPage] 
     * @param {string} [pageSize] 
     * @param {string} [filter] 
     * @param {string} [searchString] 
     * @param {string} [customDocumentModels] 
     * @param {string} [range] 
     * @param {string} [month] 
     * @param {string} [year] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxInvoiceApi
     */
    public taxInvoiceIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: AxiosRequestConfig) {
        return TaxInvoiceApiFp(this.configuration).taxInvoiceIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To Accept payment with the paymentModel
     * @param {number} id 
     * @param {string} culture 
     * @param {PaymentModel} paymentModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxInvoiceApi
     */
    public taxInvoiceReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: AxiosRequestConfig) {
        return TaxInvoiceApiFp(this.configuration).taxInvoiceReceivePayment(id, culture, paymentModel, options).then((request) => request(this.axios, this.basePath));
    }
}


